//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-

// **********************************************************************
// * CAVIUM CONFIDENTIAL                                                 
// *                                                                     
// *                         PROPRIETARY NOTE                            
// *                                                                     
// * This software contains information confidential and proprietary to  
// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
// * transferred to other documents, or disclosed to third parties, or   
// * used for any purpose other than that for which it was obtained,     
// * without the prior written consent of Cavium, Inc.                   
// * (c) 2011, Cavium, Inc.  All rights reserved.                      
// * (utg v0.3.3)
// ***********************************************************************
// File:   global_env.sv
// Author: bhunter
/* About:  Global Environment
 *************************************************************************/


`ifndef __GLOBAL_ENV_SV__
   `define __GLOBAL_ENV_SV__

   `define DEFAULT_TOPO_DEPTH  4
   `define DEFAULT_QUIET_DRAIN_TIME 20ns

`include "global_bug_entry.sv"
`include "global_watchdog.sv"
`include "global_heartbeat_mon.sv"
`include "global_misc_dpi.sv"
`include "global_table_printer.sv"

// class: env_c
// The Global environment, instantiated in all testbenches at the global scope.
class env_c extends uvm_env;
   `uvm_component_utils_begin(global_pkg::env_c)
      `uvm_field_int(run_count,   UVM_DEFAULT | UVM_DEC)
      `uvm_field_int(topo_depth,  UVM_DEFAULT | UVM_DEC)
   `uvm_component_utils_end

   //----------------------------------------------------------------------------------------
   // Group: Configuration Fields

   // var: run_count
   // The number of times that this simulation will loop over the run-time phases
   int run_count = 1;
   
   // var: topo_depth
   // The depth of topology printing (-1 means that it was not set in config_db)
   int topo_depth = -1;

   //----------------------------------------------------------------------------------------
   // Group: Fields

   // var: global_tbc_vi
   // Virtual interface to write stuff in tbv_common
   virtual global_tbc_intf global_tbc_vi;

   // var: watchdog
   // Looks for deadlocks or watchdog timeouts.  Calls global_stop_request on either.
   watchdog_c watchdog;

   // var: bug_registry
   // Bug Registry. Each bug is associated with the McBuggin number
   bug_entry_c bug_registry[int];

   // var: heartbeat
   // Monitors heartbeat of registered components during main and shutdown phases
   heartbeat_mon_c heartbeat_mon;

   // var: current_phase
   // This holds the current run-time phase of the test
   local uvm_phase current_phase;

   // var: stats_clk
   // This holds a reference to the clock used to calculate runtime stats
   // It should be the clock that runs most of the logic in the DUT
   // It should be set through the set_stats_clk function
   local cn_pkg::clk_drv_c stats_clk;

   // var: print_stats_enabled
   // For internal control. Don't touch
   local bit print_stats_enabled;

   // var: print_pid_enabled
   // For internal control. Don't touch
   local bit print_pid_enabled;

   // var: verr_timeout_time
   // Minimum time to allow enabling of verilog errors
   int       verr_timeout_time;

   // var: idle_checks
   // Number of idle checks to perform at the end of the test
   int       idle_checks;
   
   // var: gate_rand
   // Enable gate randomization
   local bit [1:0] gate_rand;

   // var: csr_print
   //  callbacks to print nice messages when registers read/written from UVM
   global_csr_print_cb_c csr_print;

   //----------------------------------------------------------------------------------------
   // Group: Methods
   function new(string name="env",
                uvm_component parent=null);

      string proj_mode;
      
      super.new(name, parent);

      if(!$value$plusargs("projmode=%s", proj_mode))
        `cn_err(("Error parsing command-line arg: +proj_mode"))

      if(!$value$plusargs("verrtime=%d", verr_timeout_time))
        `cn_err(("Error parsing command-line arg: +verrtime"))

      $value$plusargs("gate_rand=%d", gate_rand);

      if(proj_mode == "uvm") begin
         print_stats_enabled = 1;
         print_pid_enabled = 1;
         idle_checks = 1;
         if(gate_rand != 0 && verr_timeout_time < 20) begin
            verr_timeout_time = 20;
         end
      end else if(proj_mode == "hybrid") begin
         print_stats_enabled = 0;
         print_pid_enabled = 0;
         verr_timeout_time = 0;
         idle_checks = 0;
         gate_rand = 0;
      end else begin
         `cn_fatal(("Global env not compatible with project mode \"%s\"",proj_mode))
      end
         
      // this file fills in the bug registry.  the global_macros.sv must have been
      // previously `included
      `include "gen/global_bug_registry.sv"
   endfunction : new

   ////////////////////////////////////////////
   // func: build_phase
   // Connect the hearbeat mon and wdog
   virtual function void build_phase(uvm_phase phase);
      super.build_phase(phase);

      `cn_get_intf(virtual global_tbc_intf, "global_pkg::global_tbc_intf", "this", global_tbc_vi);
      
      watchdog = watchdog_c::type_id::create("watchdog", this);
      heartbeat_mon = heartbeat_mon_c::type_id::create("heartbeat_mon", this);
   endfunction : build_phase

   ////////////////////////////////////////////
   // func: connect_phase
   // Connect the hearbeat mon and wdog
   virtual function void connect_phase(uvm_phase phase);
      super.connect_phase(phase);

      // register print callbacks (if level is high enough)
      if(uvm_report_enabled(UVM_MEDIUM,UVM_INFO)) begin
         csr_print = new();
         uvm_callbacks #(uvm_reg, uvm_reg_cbs)::add(null, csr_print);
         uvm_callbacks #(uvm_reg, uvm_reg_cbs)::display();
      end
   endfunction : connect_phase
   
   ////////////////////////////////////////////
   // func: end_of_elaboration_phase
   // Check that everything has been set-up correctly
   virtual function void end_of_elaboration_phase(uvm_phase phase);
      super.end_of_elaboration_phase(phase);

      if(print_stats_enabled == 1 && stats_clk == null) begin
         `cn_warn(("stats_clk == null, clock period stats will be disabled"))
      end
      
   endfunction : end_of_elaboration_phase

   ////////////////////////////////////////////
   // func: start_of_simualtion_phase
   // Print the bug registry and the topology
   virtual function void start_of_simulation_phase(uvm_phase phase);
      super.start_of_simulation_phase(phase);

      if(print_pid_enabled == 1) begin
         print_pid_data();
      end
      
      //print_bug_registry(); //not printing bugs in SV env- raja

      // plusargs override configured value
      // configured value overrides DEFAULT_TOPO_DEPTH
      if(!$value$plusargs("UVM_TOPO_DEPTH=%d", topo_depth)) begin
         if(topo_depth == -1)
            topo_depth = (get_report_verbosity_level())? `DEFAULT_TOPO_DEPTH:0;
         else
            topo_depth = 0;
      end
      
      if(topo_depth)
         print_topology(uvm_top, topo_depth);
   endfunction
   
   ////////////////////////////////////////////
   // Func: run_phase
   // Raises phase objection and waits on clock to start
   virtual task run_phase(uvm_phase phase);
      super.run_phase(phase);

      global_tbc_vi.debug_level = get_report_verbosity_level();

      fork
         begin
            still_going();
         end
      join;

   endtask

   ////////////////////////////////////////////
   // Func: pre_reset_phase
   // Raises phase objection and waits on clock to start
   virtual task pre_reset_phase(uvm_phase phase);
      phase.raise_objection(this);
      super.pre_reset_phase(phase);
      if(stats_clk != null) begin
         repeat(10)
           @(posedge stats_clk.clk_vi.clk);
      end
      phase.drop_objection(this);
   endtask : pre_reset_phase

   ////////////////////////////////////////////
   // Func: reset_phase
   // Drives gate_rand
   virtual task reset_phase(uvm_phase phase);

      global_tbc_vi.gate_rand = gate_rand;

      fork
         begin  // wait for the command line timeout and contribute when it does
            if(verr_timeout_time != -1 && global_tbc_vi.verr_enable == 1'b0) begin
               #(verr_timeout_time);
               global_tbc_vi.verr_enable = 1'b1;
            end
         end
      join;

   endtask : reset_phase
   
   ////////////////////////////////////////////
   // Func: post_shutdown_phase
   // Control idle signal at the end of the test
   virtual task post_shutdown_phase(uvm_phase phase);

      // knock down idle 1ns after it goes high
      while(1) begin
         @(posedge global_tbc_vi.idle) begin
            #1;
            global_tbc_vi.idle = 1'b0;
            #1;
            phase.drop_objection(this);
         end
      end
      
   endtask : post_shutdown_phase

   ////////////////////////////////////////////
   // func: check phase
   // check for end of run errors
   virtual function void check_phase(uvm_phase phase);
      super.check_phase(phase);
   endfunction : check_phase

   ////////////////////////////////////////////
   // func: final phase
   // Print testbench stats
   virtual function void final_phase(uvm_phase phase);
      super.final_phase(phase);
      
      if(print_stats_enabled == 1) begin
         print_stats();
      end
      
   endfunction : final_phase
      
   ////////////////////////////////////////////
   // funcs: Changes the current_phase field
   virtual function void phase_started(uvm_phase phase);
      super.phase_started(phase);
      current_phase = phase;
      `cn_info(("Entered phase: %s", current_phase.get_name()))
   endfunction : phase_started


   ////////////////////////////////////////////
   // Func: phase_ready_to_end
   // Callback when a phase ready to ends
   virtual function void phase_ready_to_end(uvm_phase phase);
      super.phase_ready_to_end(phase);

      // at the end of the shutdown phase, consider the run_count
      // this does NOT happen at the end of the post_shutdown phase, because by then
      // the run phase has already terminated
      if(phase.get_imp() == uvm_shutdown_phase::get()) begin
         run_count -= 1;
         if(run_count > 0) begin
            `cn_info(("-------------------------------------------------------"))
            `cn_info(("That was fun! Let's do it again! (%0d more time%s...)", run_count, (run_count > 1? "s":"")))
            `cn_info(("-------------------------------------------------------"))

            if(phase.get_objection().get_objection_count()) begin
               `cn_err(("The shutdown phase was about to end, but it was re-raised:"))
               phase.get_objection().display_objections();
            end
            phase.jump(uvm_pre_reset_phase::get());
         end
      end

      if(phase.get_imp() == uvm_post_shutdown_phase::get()) begin
         //raise idle right after post_shutdown because we want
         //to make sure testbench traffic can't take time anymore
         if(idle_checks > 0) begin
            global_tbc_vi.idle = 1'b1;
            idle_checks = idle_checks-1;
            phase.raise_objection(this,"to strobe idle");
         end
      end 
   endfunction : phase_ready_to_end
   
   ////////////////////////////////////////////
   // Func: phase_ended
   // Callback when a phase ends
   virtual function void phase_ended(uvm_phase phase);
      super.phase_ended(phase);

      if(phase.get_imp() == uvm_reset_phase::get()) begin
         if(global_tbc_vi.verr_enable == 1'b0) begin
            `cn_err(("VERRTIME must expire before reset phase ends!"));
         end
      end
   endfunction : phase_ended

   ////////////////////////////////////////////
   // func: pre_abort
   // Print testbench stats
   virtual function void pre_abort();
            
      if(print_stats_enabled == 1) begin
         print_stats();
      end
      
   endfunction : pre_abort
   
   ////////////////////////////////////////////
   // func: bug_fixed
   virtual function int bug_fixed(int bug_num);
      if(bug_registry.exists(bug_num)) begin
         return bug_registry[bug_num].is_fixed;
      end 
      else begin 
         $display("Warning-Fix for Bug:%6d missing! Add fid:0(not fixed) or fid:1(fixed) to bugs.bdf", bug_num);
         return 0;
      end
   endfunction : bug_fixed
         
   ////////////////////////////////////////////
   // func: print_bug_registry
   virtual function void print_bug_registry();
      int  dbgLvl = get_report_verbosity_level();
      $display("------------------------------------------------------------------");
      $display("-- SV BUG REGISTRY");
      $display("------------------------------------------------------------------");
      $display(" Fix  :  Bug #  - Block Title");
      foreach(bug_registry[bug_num])
        if(!bug_registry[bug_num].is_fixed || (dbgLvl==200))
          $display(bug_registry[bug_num].convert2string());
      $display("------------------------------------------------------------------");
   endfunction : print_bug_registry
   
   ////////////////////////////////////////////
   // func: print_topology
   virtual function void print_topology(uvm_object _object,
                                        int _depth,
                                        int _name_width=-1,
                                        int _type_width=-1);
      
      global_table_printer_c printer = new();
      int topo_name_width, topo_type_width;
      string topology;
      
      printer.knobs.depth = _depth;
      printer.knobs.indent = 3;

      topology = _object.sprint(printer);
      `cn_info(("Printing the %s topology at depth %0d:", _object.get_full_name(), _depth))
      $display("%s", topology);
   endfunction : print_topology

   ////////////////////////////////////////////
   // func: print_pid_data
   function void print_pid_data();

      string from_host;
      string sim_dir;
      string data;
      int    ss_rval;
      bit [31:0] pid;
      bit [31:0] ppid;
      string     hostname;
      string     job_id;

      hostname = get_hostname_dpi();
      
      pid = getpid_dpi();

      ppid = getppid_dpi();
      
      job_id = getenv_dpi("JOB_ID");
            
      data = $sformatf("%s %1d %1d %s",hostname,pid,ppid,job_id);
      
      if($value$plusargs("from_host=%s", from_host)) begin
         ss_rval = socket_send_dpi(from_host,data);
      end else if($value$plusargs("sim_dir=%s", sim_dir)) begin
         integer pid_fd;
         pid_fd = $fopen({sim_dir,"/.pid"});
         $fdisplay(pid_fd,data);
         $fflush(pid_fd);
         $fclose(pid_fd);
      end
            
      if(ss_rval < 0)
        `cn_err(("Failed to get host/port to open socket"))
      else if(ss_rval > 0)
        `cn_warn(("Failed to send piddata via socket"))
      
   endfunction
   
   ////////////////////////////////////////////
   // task: still_going
   // Prints "Still going at 12345.6 cycles/sec..." every 5000ns
   virtual task still_going();
      string hostname;
      string job_id;
      
      real cyc_sec;
      real old_time;
      real new_time;
      real old_sim_time;
      real new_sim_time;
      real rtime;
      real utime;
      real stime;

      if (!print_stats_enabled)
        return;
      
      // Print a welcome message so we know the host and jobid right away
      hostname = get_hostname_dpi();
      job_id   = getenv_dpi("JOB_ID");
      job_id   = (job_id == "") ? "0" : job_id;
      `cn_info(("Welcome to the testbench! [host:%s jobid:%s]", get_hostname_dpi(), getenv_dpi("JOB_ID")))

      // Print the "Still going" message every 5000ns
      if(stats_clk != null) begin
         get_times_dpi(rtime,utime,stime);
         old_time = (utime+stime)/100;
         old_sim_time = $time()/real'(1ps);
      
         forever begin
            #(5000ns);
            get_times_dpi(rtime,utime,stime);
            new_time = (utime+stime)/100;
            new_sim_time = $time()/real'(1ps);
            cyc_sec = ((new_sim_time-old_sim_time)/stats_clk.period_ps)/(new_time-old_time);
            old_time = new_time;
            old_sim_time = new_sim_time;
            `cn_info(("Still going at %5.1f cycles/sec...",cyc_sec))
         end
      end else begin
         forever begin
            #(5000ns);
            `cn_info(("Still going..."))
         end
      end
      
   endtask : still_going

   ////////////////////////////////////////////
   // func: print_stats
   function void print_stats();
      real      rtime;
      real      utime;
      real      stime;
      real      sim_time;
      real      cyc_time;
      real      cycsec;

      string    job_id;
      string    hostname;

      bit [31:0] seed_value;
      
      get_times_dpi(rtime,utime,stime);

      rtime = (rtime-get_wall_clock_start_dpi())/100;
      utime = utime/100;
      stime = stime/100;

      sim_time = $realtime()/real'(1ns);

      if(stats_clk != null) begin
         cyc_time = stats_clk.period_ps/real'(1000);

         cycsec = (($realtime()/real'(1ps))/stats_clk.period_ps)/(utime+stime);
      end
      
      job_id   = getenv_dpi("JOB_ID");
      hostname = get_hostname_dpi();

      if(!$value$plusargs("seed=%d", seed_value))
        `cn_err(("Error parsing command-line arg: +seed"))
      
      $display("*************************************************************************");
      $display("Testbench Stats");
      $display($sformatf("\t  Sim host: %s",hostname));
      $display($sformatf("\t    Job ID: %s",job_id));
      $display($sformatf("\t      Seed: %1d",seed_value));
      $display($sformatf("\t  Sim time: %3.2fns",sim_time));
      if(stats_clk != null) begin
         $display($sformatf("\t  Cyc time: %3.2fns",cyc_time));
      end
      $display($sformatf("\t Real time: %3.2fs",rtime));
      $display($sformatf("\t User time: %3.2fs",utime));
      $display($sformatf("\t  Sys time: %3.2fs",stime));
      if(stats_clk != null) begin
         $display($sformatf("\t Cycle/sec: %3.2f",cycsec));
      end
      $display("*************************************************************************");

   endfunction : print_stats
   
   ////////////////////////////////////////////
   // func: get_current_phase
   // Return the currently running phase
   virtual   function uvm_phase get_current_phase();
      return current_phase;
   endfunction : get_current_phase

   //****************************************************************************************
   // func: set_stats_clk
   function void set_stats_clk(cn_pkg::clk_drv_c _stats_clk);
      
      if(env.heartbeat_mon == null) begin
         `cn_fatal(("Trying to set stats_clk on a null heartbeat_mon. global env should be created in the build_phase. stats_clk should be set in the connect_phase."))
      end
      if(_stats_clk == null) begin
         `cn_fatal(("Trying to set stats_clk to null"))
      end
      
      stats_clk = _stats_clk;
      heartbeat_mon.stats_clk = _stats_clk;
      
   endfunction
   
endclass : env_c

//****************************************************************************************
// instantiate this class so that it is visible to all importers
// The class must be ::create'd by the base test
static env_c env;

   
`endif // __GLOBAL_ENV_SV__
