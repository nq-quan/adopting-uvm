//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-

`ifdef PROJ_INCLUDES_UVM
import uvm_pkg::*;
`endif

reg tbv__idle;
reg tbv__verr_enable;
integer tbv__debug_level;

// use tbv__svfcov_enable to gate the new() of covergroups in rtl code
// NOTE: use the macro from cn_defines.vh as it will alwayse scope correctly
//   `define cn_svfcov_enable          `SYS_TB_PATH.tbv__svfcov_enable
// Set the value of tbv__svfcov_enable at elaboration time so all initial blocks get the same value;
logic tbv__svfcov_enable = $test$plusargs("svfcov");

reg tbvc__idle;
initial tbvc__idle = 0;

   reg tbvc__verr_enable;
   initial tbvc__verr_enable = 0;

   integer tbvc__debug_level;
   initial tbvc__debug_level = 0;

   reg [1:0] tbvc__gate_rand;
   initial tbvc__gate_rand = 'x;   // I want the X to find the transition from !X
   

   //Verilator and CVER only
   `ifdef VCD_TRACE
   initial begin
      if ($test$plusargs("capturevcd")) begin
         #0   $dumpvars(`VCD_DEPTH,`VCD_SCOPE);
         #0.1 $dumpon;
      end
   end
   `endif

   //FSDB Tracing
   `ifdef HAVE_VERDI_WAVE_PLI
   reg [1000:0] fsdb_string;
   initial begin
      if($test$plusargs("fsdb_trace")) begin
         static sps_pkg::sps_tr_recorder my_recorder = new();
         uvm_default_recorder = my_recorder;
         uvm_config_db#(int)::set(uvm_top, "*", "recording_detail", UVM_FULL);
         `cn_info_hdl(("REPORT FILTER ON /\\*Verdi3\\* FSDB WARNING: The FSDB file already exists/"));
         if ($value$plusargs("fsdb_outfile=%s", fsdb_string))
            $fsdbDumpfile(fsdb_string);
         if($value$plusargs("fsdb_siglist=%s", fsdb_string))
            $fsdbDumpvars("+all");
      end
   end
   `endif

   `ifdef RSL_JAM
      `include "tbv_rsljam.v"
   `else
   reg [4:0]    tbv__rsl_id;
   wire         tbv__rsl_gnt = 1'b1;
   `endif



   ////////////////////////////////////////////////////////////////////////////////
   // Randomized initial state of the RTL
   ////////////////////////////////////////////////////////////////////////////////
   `ifdef RTL_RAND_SCOPE
   integer      rtl_xes;
   integer      rtl_rand;
   integer      rtl_i;
   integer      rtl_debug;
   initial begin
      fork begin
         if ($value$plusargs("rtl_rand=%d",rtl_rand)) begin
            if ($value$plusargs("gate_rand_dbg=%d",rtl_debug))
               $cn_gate_debug(rtl_debug);
            for (rtl_i=0; rtl_i<20; rtl_i=rtl_i+1) begin
               $cn_gate_randomize(`CN_STRINGIFY(`RTL_RAND_SCOPE), rtl_rand, rtl_xes);
               #(0.1234567);  // Or random delay - point is to have it not be modulus of any clock frequency
            end
         end
      end
         begin
            #20;
         end
      join
   end
   `endif

   ////////////////////////////////////////////////////////////////////////////////
   // Randomized initial state of the gates
   ////////////////////////////////////////////////////////////////////////////////
   reg [1:0]     tbv__gate_rand;
   `ifdef GATE_RAND_SCOPE
   integer       gate_debug;
   initial begin
      if ($value$plusargs("gate_rand_dbg=%d",gate_debug))
         $cn_gate_debug(gate_debug);
   end
   `endif

   //****************************************************************************************
   // UVM or Hybrid Testbenches Only
   //****************************************************************************************
   `ifdef PROJ_INCLUDES_UVM

   //These values reflect only the settings of the UVM side of the testbench and
   //they should NOT be use by RTL because they will not hold up in a hybrid testbench
   logic uvm_only__idle;
   logic uvm_only__verr_enable;
   integer uvm_only__debug_level;
   logic [1:0] uvm_only__gate_rand;
   int     mode_cheat; //set this below based on string mode

   global_tbc_intf global_tbc_i(.idle(uvm_only__idle),
                                .verr_enable(uvm_only__verr_enable),
                                .debug_level(uvm_only__debug_level),
                                .gate_rand(uvm_only__gate_rand));


   //set some of these variables use by RTL based on TestBuilder and UVM
   assign tbv__idle =        (mode_cheat == 0) ? tbvc__idle :
                             (mode_cheat == 1) ? uvm_only__idle :
                             (mode_cheat == 2) ? tbvc__idle :
                             /* default */       1'b0;

   assign tbv__verr_enable = (mode_cheat == 0) ? tbvc__verr_enable & uvm_only__verr_enable :
                             (mode_cheat == 1) ? uvm_only__verr_enable :
                             (mode_cheat == 2) ? tbvc__verr_enable :
                             /* default */       1'b0;
   
   assign tbv__debug_level = (tbvc__debug_level==0&&uvm_only__debug_level!=0) ? uvm_only__debug_level : tbvc__debug_level;

   assign tbv__gate_rand   = (mode_cheat == 0) ? tbvc__gate_rand :
                             (mode_cheat == 1) ? uvm_only__gate_rand :
                             (mode_cheat == 2) ? tbvc__gate_rand :
                             /* default */       1'b0;
                                
   function void setup_tbv_common_intf();
      `cn_set_intf(virtual global_tbc_intf, "global_pkg::global_tbc_intf", "this", global_tbc_i);
   endfunction
   
   /////////////////////////////////////////////////////////////////////////////
   // 1. replace the UVM report server with our cavium one.
   //    and set the timeformat
   // 2. call pre_run_test(). testbenches MUST override this with any functionality
   //    that should occur before run_test.
   // 3. call run_test.
   /////////////////////////////////////////////////////////////////////////////
   initial begin : start_uvm
      cn_pkg::report_server_c        report_server;
      string                         mode_value = "none";
      int                            unsigned                   seed_value;             
      
      // all "%t" shall print out in ns format with 9 digits and 3 decimal places
      $timeformat(-9,3,"ns",13);

      global_tbc_i.reset();

      if(!$value$plusargs("projmode=%s", mode_value))
         `cn_fatal_hdl(("Error parsing command-line arg: +proj_mode"));
      
      //Turn the mode into a number locally so it can be used in declarative statements
      if(mode_value == "uvm") begin
         mode_cheat = 1;
      end else if(mode_value == "hybrid") begin
         mode_cheat = 0;
      end else if(mode_value == "testbuilder") begin
         mode_cheat = 2;
      end
      
      if(mode_value == "uvm") begin
         report_server = cn_pkg::report_server_c::type_id::create();
      end else begin
         report_server = cn_pkg::hybrid_report_server_c::type_id::create();
      end
      
      // replace uvm_report_server with cn_report_server_c
      uvm_pkg::uvm_report_server::set_server(report_server);

      if(!$value$plusargs("seed=%d", seed_value))
         `cn_err_hdl(("Error parsing command-line arg: +seed"));
      `cn_info_hdl(("Running simulation with seed: %0d",seed_value));

      if(mode_value != "testbuilder") begin
         setup_tbv_common_intf();
         
         // testbenches must create this zero-time function
         pre_run_test();
         
         run_test();
      end 
   end : start_uvm

   ////////////////////////////////////////////
   // Turn off assertions in verilog until
   //  verr_enable is true
   ////////////////////////////////////////////
   initial begin : assertion_disable
      `cn_info_hdl(("Disabling assertions in the RTL"));
      $assertoff(0,`SYS_TB_PATH);
      $asserton(1,`SYS_TB_PATH);
      @(posedge tbv__verr_enable);
      `cn_info_hdl(("Enabling assertions in the RTL"));
      $asserton();
   end : assertion_disable

   ////////////////////////////////////////////
   // Needed for UVM 1.1c
   // turn these warnings off: UVM/FLD/SET/BSY
   ////////////////////////////////////////////
   initial begin
      #(1ps);
      uvm_top.set_report_severity_id_action(UVM_WARNING, "UVM/FLD/SET/BSY", UVM_NO_ACTION);
      uvm_top.set_report_severity_id_action_hier(UVM_ERROR, "SEQREQZMB", UVM_NO_ACTION);
   end

   initial begin
      #(1ns);
      if((mode_cheat == 0 || mode_cheat == 1) && global_pkg::env == null) begin
         `cn_fatal_hdl(("Must create global env when running UVM"));
      end
   end
   
   ////////////////////////////////////////////
   // Functional Coverage
   ////////////////////////////////////////////
   initial begin : functional_coverage
      integer svfcov;
      integer fcov_setting = ($value$plusargs("svfcov=%d", svfcov));
      if (fcov_setting) begin
         uvm_config_db#(int)::set(uvm_top, "*", "coverage_enable", svfcov);
      end else begin
         uvm_config_db#(int)::set(uvm_top, "*", "coverage_enable", 0);
      end
   end

   reg [31:0] rand_seed;
   bit [7:0]  msg_severity;
   bit [7:0][1023:0] msg_text;
   bit [7:0][1023:0] msg_scope;
   bit [7:0][1023:0] msg_filename;
   int               msg_lineno;
   bit               msg_ready;
   
   initial begin
      string mode_value = "none";
      uvm_pkg::uvm_cmdline_processor cmdline_processor = uvm_pkg::uvm_cmdline_processor::get_inst();
      int    rc = cmdline_processor.get_arg_value("+projmode=", mode_value);
      if(mode_value == "uvm") begin
         
         ////////////////////////////////////////////
         // Calls to `cn_rand will need a seed
         rand_seed = $urandom();

      end else begin

         disable VPI_MSG_TRAP;
         
         // ensure that UVM never calls $finish
         uvm_top.finish_on_completion = 0;
      end
   end
   
   //****************************************************************************************
   // UVM-Only
   //****************************************************************************************

   ////////////////////////////////////////////////////////////////////////////////
   // Trap $cnInfo, $cnWarn, $cnErr, $cnFatal calls
   //   VPI acts like a mailbox.  If messages are ready to be printed, then it will
   //   set msg_ready high, and this will loop through messages.  Print them out one
   //   at a time and then clear msg_ready
   ////////////////////////////////////////////////////////////////////////////////
   
   always @(posedge msg_ready) begin : VPI_MSG_TRAP
      while($cnGetMessage()) begin
         case(msg_severity)
            "I": begin                 uvm_report_info   (msg_scope, msg_text, uvm_pkg::UVM_NONE, msg_filename, msg_lineno); end
            "E": begin if(tbv__verr_enable === 'b1) uvm_report_error  (msg_scope, msg_text, uvm_pkg::UVM_NONE, msg_filename, msg_lineno); end
            "W": begin if(tbv__verr_enable === 'b1) uvm_report_warning(msg_scope, msg_text, uvm_pkg::UVM_NONE, msg_filename, msg_lineno); end
            "F": begin                 uvm_report_fatal  (msg_scope, msg_text, uvm_pkg::UVM_NONE, msg_filename, msg_lineno); end
            "D": begin                 uvm_report_info   (msg_scope, msg_text, uvm_pkg::UVM_NONE, msg_filename, msg_lineno); end
            default: 
               uvm_report_fatal("VPI Message Calls", $sformatf("Unknown severity '%s'", msg_severity), msg_filename, msg_lineno);
         endcase
      end
      msg_ready = 0;
   end

   `else // !PROJ_INCLUDES_UVM
   assign tbv__idle = tbvc__idle;
   assign tbv__verr_enable = tbvc__verr_enable;
   assign tbv__debug_level = tbvc__debug_level;

   `endif
   
   // Root message tag instance
   `cn_msg_tag("vlog");

