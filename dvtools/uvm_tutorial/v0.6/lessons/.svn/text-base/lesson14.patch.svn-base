Index: verif/alutb/tests/ref_model.sv
===================================================================
--- verif/alutb/tests/ref_model.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/tests/ref_model.sv	(.../verif)	(revision 0)
@@ -0,0 +1,51 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   ref_model.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __REF_MODEL_SV__
+   `define __REF_MODEL_SV__
+
+`include "basic.sv"
+
+// class: ref_model_test_c
+// Test the ALU using the predictor as a reference model
+class ref_model_test_c extends basic_test_c;
+   `uvm_component_utils(ref_model_test_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      uvm_config_db#(int)::set(this, "alutb_env.alu_agent", "ref_model", 1);
+
+      // reset the interface to avoid x-checkers
+      alutb_tb_top.alu_i.reset();
+   endfunction : build_phase
+   
+endclass : ref_model_test_c
+   
+`endif // __REF_MODEL_SV__
+      
\ No newline at end of file
Index: verif/alutb/tests/kval.sv
===================================================================
--- verif/alutb/tests/kval.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/tests/kval.sv	(.../verif)	(revision 0)
@@ -0,0 +1,50 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   kval.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __KVAL_SV__
+   `define __KVAL_SV__
+
+   
+   `include "basic.sv"
+
+// class: kval_test_c
+// Constraint K_VAL from 9..20
+class kval_test_c extends basic_test_c;
+   `uvm_component_utils_begin(kval_test_c)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   constraint kval_cnstr {
+      reg_block.ALU_CONST.K_VAL.value inside {[9:20]};
+   }
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+endclass : kval_test_c
+   
+`endif // __KVAL_SV__
+      
\ No newline at end of file
Index: verif/alutb/tests/basic.sv
===================================================================
--- verif/alutb/tests/basic.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/alutb/tests/basic.sv	(.../verif)	(working copy)
@@ -23,13 +23,11 @@
    
    `include "base_test.sv"
 
-// class: basic_test_c
-// A basic ALU test
 class basic_test_c extends base_test_c;
    `uvm_component_utils(basic_test_c)
 
    //----------------------------------------------------------------------------------------
-   // Methods
+   // Group: Methods
    function new(string name="test",
                 uvm_component parent=null);
       super.new(name, parent);
@@ -37,10 +35,13 @@
 
    ////////////////////////////////////////////
    // func: build_phase
-   virtual function void build_phase(uvm_phase phase);
+    virtual function void build_phase(uvm_phase phase);
       super.build_phase(phase);
+
+      uvm_config_db#(uvm_object_wrapper)::set(this, "alutb_env.alu_agent.sqr.main_phase",
+                                              "default_sequence", alu_pkg::lib_seq_c::type_id::get());
    endfunction : build_phase
-   
+
 endclass : basic_test_c
    
 `endif // __BASIC_SV__
Index: verif/alutb/tests/div0.sv
===================================================================
--- verif/alutb/tests/div0.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/tests/div0.sv	(.../verif)	(revision 0)
@@ -0,0 +1,70 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   div0.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __DIV0_SV__
+   `define __DIV0_SV__
+
+   `include "basic.sv"
+
+//****************************************************************************************
+// class: div0_item_c
+// Causes a divide-by-zero on 50% of all divide operations
+class div0_item_c extends alu_pkg::item_c;
+   `uvm_object_utils(div0_item_c)
+
+   constraint protocol_cnstr {
+      (operation == DIV_A_B) -> beta dist { 0 :/ 50,
+                                            [1:'hffff] :/ 50};
+      (operation == DIV_B_A) -> alpha dist { 0 :/ 50,
+                                            [1:'hffff] :/ 50};
+      (operation == SUB_A_B) -> alpha > beta;
+      (operation == SUB_B_A) -> beta > alpha;
+   }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="div0_item");
+      super.new(name);
+   endfunction : new
+endclass : div0_item_c
+
+//****************************************************************************************
+// class: div0_test_c
+// Uses the div0_item_c class instead
+class div0_test_c extends basic_test_c;
+   `uvm_component_utils(div0_test_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="div0_test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      set_type_override_by_type(alu_pkg::item_c::get_type(), div0_item_c::get_type());
+   endfunction : build_phase
+
+endclass : div0_test_c
+
+`endif // __DIV0_SV__
Index: verif/alutb/tests/exer.sv
===================================================================
--- verif/alutb/tests/exer.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/tests/exer.sv	(.../verif)	(revision 0)
@@ -0,0 +1,51 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   exer.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __EXER_SV__
+   `define __EXER_SV__
+
+   `include "basic.sv"
+
+// class: exer_test_c
+// Turns on all possible values of K_VAL and C_VAL
+class exer_test_c extends basic_test_c;
+   `uvm_component_utils(exer_test_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+   constraint const_knob_cnstr {
+      cfg.alu_const_knob dist { alutb_pkg::cfg_c::INNOCUOUS :/ 20,
+                                alutb_pkg::cfg_c::SMALL     :/ 50,
+                                alutb_pkg::cfg_c::LARGE     :/ 15,
+                                alutb_pkg::cfg_c::XLARGE    :/ 5,
+                                alutb_pkg::cfg_c::UNLIMITED :/ 10
+      };
+   }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="alu_exer",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+endclass : exer_test_c
+   
+`endif // __EXER_SV__
+      
\ No newline at end of file
Index: verif/alutb/tests/duty_cycle.sv
===================================================================
--- verif/alutb/tests/duty_cycle.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/tests/duty_cycle.sv	(.../verif)	(revision 0)
@@ -0,0 +1,50 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   duty_cycle.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __DUTY_CYCLE_SV__
+   `define __DUTY_CYCLE_SV__
+
+   `include "base_test.sv"
+   `include "clk_duty_cycle.sv"
+
+// class: duty_cycle_test_c
+// Run using the clk_duty_cycle_c instead of cn_pkg::clk_drv_c
+class duty_cycle_test_c extends base_test_c;
+   `uvm_component_utils(duty_cycle_test_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="duty_cycle_test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      set_type_override_by_type(cn_pkg::clk_drv_c::get_type(),
+                                clk_duty_cycle_c::get_type(), .replace(1));
+      super.build_phase(phase);
+   endfunction : build_phase
+
+endclass : duty_cycle_test_c
+   
+`endif // __DUTY_CYCLE_SV__
+      
\ No newline at end of file
Index: verif/alutb/tests/fast_clk.sv
===================================================================
--- verif/alutb/tests/fast_clk.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/tests/fast_clk.sv	(.../verif)	(revision 0)
@@ -0,0 +1,59 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   fast_clk.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __FAST_CLK_SV__
+   `define __FAST_CLK_SV__
+
+   
+   `include "base_test.sv"
+
+// class: fast_clk_test_c
+// Run with a faster clock
+class fast_clk_test_c extends base_test_c;
+   `uvm_component_utils_begin(fast_clk_test_c)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+      tb_clk_drv.randomize(period_ps) with {
+         period_ps inside {[1800:1999]};
+      };
+      `cn_info(("Selected a period of %0dps.", tb_clk_drv.period_ps))
+   endfunction : end_of_elaboration_phase
+
+endclass : fast_clk_test_c
+   
+`endif // __FAST_CLK_SV__
+      
\ No newline at end of file
Index: verif/alutb/clk_duty_cycle.sv
===================================================================
--- verif/alutb/clk_duty_cycle.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/alutb/clk_duty_cycle.sv	(.../verif)	(revision 0)
@@ -0,0 +1,56 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   clk_duty_cycle.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __CLK_DUTY_CYCLE_SV__
+   `define __CLK_DUTY_CYCLE_SV__
+   
+// class: clk_duty_cycle_c
+// A clock with a duty cycle of 75/25.
+class clk_duty_cycle_c extends cn_pkg::clk_drv_c;
+   `uvm_component_utils(clk_duty_cycle_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="clk_duty_cycle",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      int uptime = 3*period_ps / 4;
+      int downtime = period_ps - uptime;
+
+      // set to initial value
+      clk_vi.clk = (init_x)? 'bx : init_value;
+      #(init_delay_ps * 1ps);
+      forever begin
+         clk_vi.clk = 1;
+         #(uptime * 1ps);
+         clk_vi.clk = 0;
+         #(downtime * 1ps);
+      end
+   endtask : run_phase
+
+endclass : clk_duty_cycle_c
+   
+`endif // __CLK_DUTY_CYCLE_SV__
+   
\ No newline at end of file
Index: verif/alutb/alutb_tb_top.sv
===================================================================
--- verif/alutb/alutb_tb_top.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/alutb/alutb_tb_top.sv	(.../verif)	(working copy)
@@ -37,6 +37,10 @@
    // The <ncb_intf> instance.
    ncb_intf ncb_i(.clk(tb_clk), .reset_n(tb_rst_n));
 
+   // obj: alu_i
+   // The <alu_intf> instance
+   alu_intf alu_i(.clk(tb_clk), .rst_n(tb_rst_n));
+
    //----------------------------------------------------------------------------------------
    // Group: DUT
 
@@ -44,6 +48,7 @@
    alu_wrapper alu_wrapper(/*AUTOINST*/
                            // Interfaces
                            .ncb_i               (ncb_i),
+                           .alu_i               (alu_i),
                            // Inputs
                            .tb_clk              (tb_clk),
                            .tb_rst_n            (tb_rst_n));
@@ -58,6 +63,8 @@
       `cn_set_intf(virtual cn_clk_intf    , "cn_pkg::clk_intf" , "tb_clk_vi", tb_clk_i);
       `cn_set_intf(virtual cn_rst_intf    , "cn_pkg::rst_intf" , "tb_rst_vi", tb_rst_i);
       `cn_set_intf(virtual ncb_intf       , "ncb_pkg::intf"    , "ncb_vi"   , ncb_i);
+      `cn_set_intf(virtual alu_intf.drv_mp, "alu_pkg::alu_intf", "drv_vi"   , alu_i.drv_mp)
+      `cn_set_intf(virtual alu_intf.mon_mp, "alu_pkg::alu_intf", "mon_vi"   , alu_i.mon_mp)
    endfunction : pre_run_test
 
    // proc: Reset Busses
Index: verif/alutb/alutb.flist
===================================================================
--- verif/alutb/alutb.flist	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/alutb/alutb.flist	(.../verif)	(working copy)
@@ -7,4 +7,11 @@
 ../../verif/alutb/alu_wrapper.sv
 ../../verif/alutb/tests/basic.sv
 ../../verif/alutb/tests/base_test.sv
+../../verif/alutb/tests/fast_clk.sv
+../../verif/alutb/tests/duty_cycle.sv
+../../verif/alutb/tests/ref_model.sv
+../../verif/alutb/tests/kval.sv
+../../verif/alutb/tests/exer.sv
+../../verif/alutb/tests/div0.sv
 
+
Index: verif/alutb/alu_wrapper.sv
===================================================================
--- verif/alutb/alu_wrapper.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/alutb/alu_wrapper.sv	(.../verif)	(working copy)
@@ -1,11 +1,10 @@
 module alu_wrapper(input logic tb_clk,
                    tb_rst_n,
-                   ncb_intf ncb_i);
+                   ncb_intf ncb_i,
+                   alu_intf alu_i);
    
    /*AUTOREGINPUT*/
    // Beginning of automatic reg inputs (for undeclared instantiated-module inputs)
-   reg                  alu_ctl;                // To dut of alu.v
-   reg [7:0]            alu_dat;                // To dut of alu.v
    reg                  erst_0a_n;              // To dut of alu.v
    reg [4:0]            frame_len;              // To dut of alu.v
    reg                  frame_len_val;          // To dut of alu.v
@@ -31,8 +30,6 @@
    // End of automatics
    /*AUTOWIRE*/
    // Beginning of automatic wires (for undeclared instantiated-module outputs)
-   wire                 alu_ready;              // From dut of alu.v
-   wire [31:0]          alu_result;             // From dut of alu.v
    wire [16:0]          ciu__dbg_dat;           // From dut of alu.v
    wire                 ciu__rst_sft_prst0;     // From dut of alu.v
    wire                 ciu__rst_sft_prst1;     // From dut of alu.v
@@ -47,6 +44,7 @@
    // obj: alu
    /*
     alu AUTO_TEMPLATE (
+    .alu_\(.*\)         (alu_i.\1[]),
     .ncb__busy         (ncb_i.outb.outb_bp[0]),
 
     .ncb__inb_\(.*\)   (ncb_i.inb.\1[]),
@@ -83,11 +81,11 @@
            .ncb__inb_opc                (ncb_i.inb.opc[3:0]),    // Templated
            .ncb__inb_src                (ncb_i.inb.src[7:0]),    // Templated
            .ncb__inb_valid              (ncb_i.inb.valid),       // Templated
-           .alu_ready                   (alu_ready),             // Templated
-           .alu_result                  (alu_result[31:0]),      // Templated
+           .alu_ready                   (alu_i.ready),           // Templated
+           .alu_result                  (alu_i.result[31:0]),    // Templated
            // Inputs
-           .alu_ctl                     (alu_ctl),               // Templated
-           .alu_dat                     (alu_dat[7:0]),          // Templated
+           .alu_ctl                     (alu_i.ctl),             // Templated
+           .alu_dat                     (alu_i.dat[7:0]),        // Templated
            .erst_0a_n                   (erst_0a_n),             // Templated
            .frame_len                   (frame_len[4:0]),        // Templated
            .frame_len_val               (frame_len_val),         // Templated
Index: verif/alutb/Makefile
===================================================================
--- verif/alutb/Makefile	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104139)
+++ verif/alutb/Makefile	(.../verif)	(working copy)
@@ -36,9 +36,10 @@
 CSR_PKGS = $(ROOT_DIR)/verif/vkits/reg/obj/unit/regs__alu.sv
 
 FLISTS= verif/vkits/cn/cn.flist \
-   verif/vkits/global/global.flist \
+	verif/vkits/global/global.flist \
 	verif/vkits/reg/reg.flist \
 	verif/vkits/ncb/ncb.flist \
+	verif/vkits/alu/alu.flist \
 	verif/vkits/alutb/alutb.flist \
 	verif/alutb/alutb.flist \
 	verif/alutb/rtl.flist
Index: verif/vkits/alu/alu.flist
===================================================================
--- verif/vkits/alu/alu.flist	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu.flist	(.../verif)	(revision 0)
@@ -0,0 +1,3 @@
++incdir+../../verif/vkits/alu
+../../verif/vkits/alu/alu_intf.sv
+../../verif/vkits/alu/alu_pkg.sv
Index: verif/vkits/alu/alu_mon.sv
===================================================================
--- verif/vkits/alu/alu_mon.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_mon.sv	(.../verif)	(revision 0)
@@ -0,0 +1,157 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_mon.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_MON_SV__
+   `define __ALU_MON_SV__
+
+   `include "alu_item.sv"
+
+// class: mon_c
+// Monitors an ALU bus and reports activity.
+class mon_c extends uvm_monitor;
+   `uvm_component_utils_begin(alu_pkg::mon_c)
+      `uvm_field_string(intf_name, UVM_ALL_ON)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   // var: intf_name
+   // The name of the virtual interface that we'll hook up to
+   string intf_name = "mon_vi";
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   // var: monitored_item_port
+   // All monitored transactions go out here
+   uvm_analysis_port #(item_c) monitored_item_port;
+
+   // var: monitored_result_port
+   // All monitored results go out here
+   uvm_analysis_port #(result_t) monitored_result_port;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: mon_vi
+   // Virtual interface to monitor
+   virtual alu_intf.mon_mp mon_vi;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="mon",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+
+      // get the interface
+      `cn_get_intf(virtual alu_intf.mon_mp, "alu_pkg::alu_intf", intf_name, mon_vi)
+
+      monitored_item_port = new("monitored_item_port", this);
+      monitored_result_port = new("monitored_result_port", this);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      forever begin
+         @(posedge mon_vi.mon_cb.rst_n);
+
+         fork
+            monitor_item();
+            monitor_result();
+            @(negedge mon_vi.mon_cb.rst_n);
+         join_any
+
+         `cn_info(("Stopping monitor due to reset."))
+         disable fork;
+      end
+
+   endtask : run_phase
+
+   ////////////////////////////////////////////
+   // func: monitor_item
+   // Watch and broadcast the transactions on the bus
+   virtual task monitor_item();
+      int num_clocks;
+      byte unsigned data[];
+      item_c item;
+
+      forever begin
+         // wait for the rising edge of the control
+         @(posedge mon_vi.mon_cb.ctl);
+
+         // determine how many clocks are in this itemaction
+         case(mon_vi.mon_cb.dat)
+            // 5-cycle transactions
+            item_c::ADD_A_B, item_c::SUB_A_B, item_c::SUB_B_A,
+            item_c::MUL_A_B, item_c::DIV_A_B, item_c::DIV_B_A :
+               num_clocks = 5;
+
+            // 3-cycle transactions
+            item_c::INC_A, item_c::INC_B, item_c::ACCUM :
+               num_clocks = 3;
+
+            // 1-cycle transactions
+            item_c::CLR_RES :
+               num_clocks = 1;
+
+            default:
+               `cn_err(("Unknown operation type: %02X", mon_vi.mon_cb.dat))
+         endcase
+
+         // collect the data for each cycle
+         data = new[num_clocks];
+         for(int clk=0; clk < num_clocks; clk++) begin
+            data[clk] = mon_vi.mon_cb.dat;
+            @(mon_vi.mon_cb);
+            if(mon_vi.mon_cb.ctl == 1)
+               `cn_err(("The CTL signal is high during a transaction that should have been %0d clocks.", num_clocks))
+         end
+
+         // create the transaction, unpack into it, and write it out the monitored_item_port
+         item = item_c::type_id::create("mon_item");
+         item.unpack_bytes(data);
+         `cn_info(("Monitored: %s", item.convert2string()))
+         monitored_item_port.write(item);
+      end
+   endtask : monitor_item
+
+   ////////////////////////////////////////////
+   // func: monitor_result
+   // Monitor the ready and result signal and broadcast it out the monitored_result_port
+   virtual task monitor_result();
+      forever begin
+         @(posedge mon_vi.mon_cb.ready);
+         `cn_info(("Monitored Result: %08X", mon_vi.mon_cb.result))
+         monitored_result_port.write(mon_vi.mon_cb.result);
+      end
+   endtask : monitor_result
+
+endclass : mon_c
+
+`endif // __ALU_MON_SV__
+   
\ No newline at end of file
Index: verif/vkits/alu/alu_pred.sv
===================================================================
--- verif/vkits/alu/alu_pred.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_pred.sv	(.../verif)	(revision 0)
@@ -0,0 +1,159 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_pred.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_PRED_SV__
+   `define __ALU_PRED_SV__
+
+`include "alu_item.sv"
+
+class pred_c extends uvm_component;
+   `uvm_component_utils_begin(pred_c)
+      `uvm_field_object(reg_block,   UVM_REFERENCE)
+      `uvm_field_int(ref_model, UVM_ALL_ON)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   // var: reg_block
+   // Auto-generated Register Block
+   alu_csr_pkg::alu_ncb_reg_block_c reg_block;
+
+   // var: ref_model
+   // When set, operates in reference model mode
+   bit ref_model = 0;
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   // var: monitored_item_imp
+   uvm_analysis_imp_item #(item_c, pred_c) monitored_item_imp;
+
+   // var: monitored_result_imp
+   uvm_analysis_imp_result #(result_t, pred_c) monitored_result_imp;
+
+   // var: seq_item_port
+   // As a reference model, pulls transactions from the sequencer
+   uvm_seq_item_pull_port #(item_c) seq_item_port;
+
+   // var: monitored_item_port
+   // As a reference model, drives out the transactions that were "driven"
+   uvm_analysis_port #(item_c) monitored_item_port;
+
+   // var: monitored_result_port
+   // As a reference model, drives out the results that were "seen"
+   uvm_analysis_port #(result_t) monitored_result_port;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: result
+   // The result of the monitored transaction is stored here and checked with the received result
+   result_t result = 0;
+
+   // var:
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="pred",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+
+      if(ref_model) begin
+         seq_item_port = new("seq_item_port", this);
+         monitored_item_port = new("monitored_item_port", this);
+         monitored_result_port = new("monitored_result_port", this);
+      end else begin
+         monitored_item_imp = new("monitored_item_imp", this);
+         monitored_result_imp = new("monitored_result_imp", this);
+      end
+
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: main_phase
+   task main_phase(uvm_phase phase);
+      item_c item;
+
+      if(ref_model) begin
+         forever begin
+            seq_item_port.get_next_item(item);
+
+            `cn_dbg(30, ("REF_MODEL: %s", item.convert2string()))
+
+            // create a delay that models the transmission of the transaction
+            #5ns;
+            monitored_item_port.write(item);
+
+            // calculate result
+            write_item(item);
+
+            // create a delay that models the ALU calulation speed
+            #15ns;
+
+            // send back the result
+            write_result(result);
+            item.result = result;
+            seq_item_port.item_done(item);
+            monitored_result_port.write(result);
+         end
+      end
+   endtask : main_phase
+
+   ////////////////////////////////////////////
+   // func: write_item
+   // Accepts ALU transactions and sets the next expected result
+   virtual function void write_item(item_c _item);
+      bit [7:0] k_val = reg_block.ALU_CONST.K_VAL.value;
+      bit [7:0] c_val = reg_block.ALU_CONST.C_VAL.value;
+
+      case(_item.operation)
+         item_c::ADD_A_B :  result = k_val * (_item.alpha + _item.beta) + c_val;
+         item_c::SUB_A_B :  result = k_val * (_item.alpha - _item.beta) + c_val;
+         item_c::SUB_B_A :  result = k_val * (_item.beta  - _item.alpha) + c_val;
+         item_c::MUL_A_B :  result = k_val * (_item.alpha * _item.beta) + c_val;
+         item_c::DIV_A_B :  result = k_val * (_item.alpha / (_item.beta? _item.beta : 1)) + c_val;
+         item_c::DIV_B_A :  result = k_val * (_item.beta  / (_item.alpha? _item.alpha : 1)) + c_val;
+         item_c::INC_A   :  result = k_val * (_item.alpha + 1) + c_val;
+         item_c::INC_B   :  result = k_val * (_item.beta  + 1) + c_val;
+         item_c::CLR_RES :  result = 0;
+         item_c::ACCUM   :  result += _item.alpha;
+      endcase
+
+      `cn_dbg(30, ("Calculated result %08X on item: %s", result, _item.convert2string()))
+   endfunction : write_item
+
+   ////////////////////////////////////////////
+   // func: write_result
+   // Called when a result is monitored
+   virtual function void write_result(result_t _result);
+      if(_result !== result)
+         `cn_err(("Actual result: %08X != Expected result: %08x",
+                  _result, result))
+   endfunction : write_result
+endclass : pred_c
+
+`endif // __ALU_PRED_SV__
+   
\ No newline at end of file
Index: verif/vkits/alu/alu_drv.sv
===================================================================
--- verif/vkits/alu/alu_drv.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_drv.sv	(.../verif)	(revision 0)
@@ -0,0 +1,130 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_drv.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_DRV_SV__
+   `define __ALU_DRV_SV__
+
+   `include "alu_item.sv"
+   `include "alu_cfg.sv"
+
+// class: drv_c
+// (Describe me)
+class drv_c extends uvm_driver#(item_c);
+   `uvm_component_utils_begin(alu_pkg::drv_c)
+      `uvm_field_string(intf_name, UVM_ALL_ON)
+      `uvm_field_object(cfg, UVM_REFERENCE)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   // var: intf_name
+   // The name of the virtual interface that we'll hook up to
+   string intf_name = "drv_vi";
+
+   // var: cfg
+   // The ALU configuration class
+   cfg_c cfg;
+   
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: drv_vi
+   // Virtual interface to drive on
+   virtual alu_intf.drv_mp drv_vi;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="drv",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      // get the interface
+      `cn_get_intf(virtual alu_intf.drv_mp, "alu_pkg::alu_intf", intf_name, drv_vi)
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      result_t prev_result;
+
+      drv_vi.reset();
+      
+      driver();
+   endtask : run_phase
+
+   ////////////////////////////////////////////
+   // func: driver
+   // Drive transactions by packing into an array of bytes, then sending two 4-bit cycles
+   // for each byte.  Then wait for the response and send it back.
+   task driver();
+      byte unsigned stream[];
+
+      @(posedge drv_vi.drv_cb.rst_n);
+
+      forever begin
+         seq_item_port.get_next_item(req);
+
+         req.pack_bytes(stream);
+         foreach(stream[x]) begin
+            @(drv_vi.drv_cb);
+
+            drv_vi.drv_cb.ctl <= (x == 0)? 1'b1 : 1'b0;
+            drv_vi.drv_cb.dat <= stream[x];
+         end
+
+         // wait 1 clock, then clear the bus
+         @(drv_vi.drv_cb);
+         drv_vi.reset();
+
+         // wait for result
+         @(posedge drv_vi.drv_cb.ready);
+         @(drv_vi.drv_cb);
+         req.result = drv_vi.drv_cb.result;
+         seq_item_port.item_done(req);
+
+         cfg.randomize(drv_inter_item_delay);
+         repeat(cfg.drv_inter_item_delay)
+           @(drv_vi.drv_cb);
+      end
+   endtask : driver
+endclass : drv_c
+   
+`endif // __ALU_DRV_SV__
Index: verif/vkits/alu/alu_item.sv
===================================================================
--- verif/vkits/alu/alu_item.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_item.sv	(.../verif)	(revision 0)
@@ -0,0 +1,123 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_item.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_ITEM_SV__
+   `define __ALU_ITEM_SV__
+
+// class: item_c
+// An ALU Transaction as a sequence item
+class item_c extends uvm_sequence_item;
+   //----------------------------------------------------------------------------------------
+   // Group: Types
+   typedef enum bit [7:0] {
+                           ADD_A_B = 0,
+                           SUB_A_B = 1,
+                           SUB_B_A = 2,
+                           MUL_A_B = 3,
+                           DIV_A_B = 4,
+                           DIV_B_A = 5,
+                           INC_A   = 6,
+                           INC_B   = 7,
+                           CLR_RES = 8,
+                           ACCUM   = 9
+                           } operation_e;
+
+   `uvm_object_utils_begin(alu_pkg::item_c)
+      `uvm_field_enum(operation_e, operation, UVM_ALL_ON)
+      `uvm_field_int (alpha,                  UVM_ALL_ON | UVM_NOPACK | UVM_NOCOMPARE)
+      `uvm_field_int (beta,                   UVM_ALL_ON | UVM_NOPACK | UVM_NOCOMPARE)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: operation
+   rand operation_e operation;
+
+   // var: A variable
+   rand bit [15:0] alpha;
+
+   // var: B variable
+   rand bit [15:0] beta;
+
+   // ensure that all operands have legal values
+   constraint protocol_cnstr {
+      (operation == DIV_A_B) -> beta != 0;
+      (operation == DIV_B_A) -> alpha != 0;
+      (operation == SUB_A_B) -> alpha > beta;
+      (operation == SUB_B_A) -> beta > alpha;
+   }
+
+   // var: result
+   // This is the result of the operation, filled in by the driver and sent back with the response
+   result_t result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="item");
+      super.new(name);
+   endfunction : new
+
+   //----------------------------------------------------------------------------------------
+   // func: convert2string
+   // Single-line printing
+   virtual function string convert2string();
+      convert2string = $psprintf("%s A:%04X B:%04X", operation, alpha, beta);
+   endfunction : convert2string
+
+   ////////////////////////////////////////////
+   // func: do_pack
+   virtual function void do_pack(uvm_packer packer);
+      super.do_pack(packer);
+
+      if(operation inside {[ADD_A_B : INC_A], ACCUM})
+         packer.pack_field_int(alpha, 16);
+      if(operation inside {[ADD_A_B : DIV_B_A], INC_B})
+         packer.pack_field_int(beta, 16);
+   endfunction : do_pack
+
+   ////////////////////////////////////////////
+   // func: do_unpack
+   virtual function void do_unpack(uvm_packer packer);
+      super.do_unpack(packer);
+
+      if(operation inside {[ADD_A_B : INC_A], ACCUM})
+         alpha = packer.unpack_field_int(16);
+      if(operation inside {[ADD_A_B : DIV_B_A], INC_B})
+         beta = packer.unpack_field_int(16);
+   endfunction : do_unpack
+
+   ////////////////////////////////////////////
+   // func: do_compare
+   virtual function bit do_compare(uvm_object rhs,
+                                   uvm_comparer comparer);
+      item_c _rhs;
+      $cast(_rhs, rhs);
+      do_compare = super.do_compare(rhs, comparer);
+      if(operation inside {[ADD_A_B : INC_A], ACCUM})
+         do_compare &= comparer.compare_field_int("alpha", alpha, _rhs.alpha, 16);
+      if(operation inside {[ADD_A_B : DIV_B_A], INC_B})
+         do_compare &= comparer.compare_field_int("beta", beta, _rhs.beta, 16);
+   endfunction : do_compare
+
+endclass : item_c
+   
+`endif // __ALU_ITEM_SV__
+
Index: verif/vkits/alu/alu_agent.sv
===================================================================
--- verif/vkits/alu/alu_agent.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_agent.sv	(.../verif)	(revision 0)
@@ -0,0 +1,148 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_agent.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_AGENT_SV__
+   `define __ALU_AGENT_SV__
+
+   
+`include "alu_drv.sv"
+`include "alu_mon.sv"
+`include "alu_sqr.sv"
+`include "alu_item.sv"
+`include "alu_pred.sv"
+`include "alu_cfg.sv"
+
+// class: agent_c
+// (Description)
+class agent_c extends uvm_agent;
+   `uvm_component_utils_begin(alu_pkg::agent_c)
+      `uvm_field_enum(uvm_active_passive_enum, is_active, UVM_ALL_ON)
+      `uvm_field_int(ref_model, UVM_ALL_ON)
+      `uvm_field_object(cfg, UVM_REFERENCE)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   // var: is_active
+   // When set to UVM_ACTIVE, the sqr and drv will be present.
+   uvm_active_passive_enum is_active = UVM_ACTIVE;
+   
+   // var: ref_model
+   // When set to 1, the predictor operates in reference mode and the monitor/driver are not enabled
+   bit ref_model = 0;
+
+   // var: cfg
+   // The ALU configuration class
+   cfg_c cfg;
+   
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   // var: monitored_item_port
+   // All monitored transactions go out here
+   uvm_analysis_port #(item_c) monitored_item_port;
+
+   // var: monitored_result_port
+   // All monitored results go out here
+   uvm_analysis_port #(result_t) monitored_result_port;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // vars: Driver, monitor, and sequencer
+   // Driver, monitor, and sequencer found in most agents
+   sqr_c sqr;
+   drv_c drv;
+   mon_c mon;
+   
+   // var: pred
+   // The predictor
+   pred_c pred;
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="agent",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+
+      uvm_config_db#(uvm_object)::set(this, "*", "cfg", cfg);
+
+      if(!ref_model)
+         mon = mon_c::type_id::create("mon", this);
+      if(is_active) begin
+         if(!ref_model)
+            drv = drv_c::type_id::create("drv", this);
+         sqr = sqr_c::type_id::create("sqr", this);
+      end
+
+      monitored_item_port = new("monitored_item_port", this);
+      monitored_result_port = new("monitored_result_port", this);
+
+      uvm_config_db#(int)::set(this, "pred", "ref_model", ref_model);
+      pred = pred_c::type_id::create("pred", this);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+
+      if(!ref_model) begin
+         if(is_active) begin
+            drv.seq_item_port.connect(sqr.seq_item_export);
+            mon.monitored_result_port.connect(sqr.monitored_result_imp);
+         end
+
+         // connect to the monitor's analysis ports
+         mon.monitored_item_port.connect(monitored_item_port);
+         mon.monitored_result_port.connect(monitored_result_port);
+         mon.monitored_item_port.connect(pred.monitored_item_imp);
+         mon.monitored_result_port.connect(pred.monitored_result_imp);
+      end else begin
+         // as a reference model
+         pred.seq_item_port.connect(sqr.seq_item_export);
+         pred.monitored_item_port.connect(monitored_item_port);
+         pred.monitored_result_port.connect(monitored_result_port);
+      end
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      super.run_phase(phase);
+   endtask : run_phase
+
+endclass : agent_c
+   
+`endif // __ALU_AGENT_SV__
+   
\ No newline at end of file
Index: verif/vkits/alu/alu_seq_lib.sv
===================================================================
--- verif/vkits/alu/alu_seq_lib.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_seq_lib.sv	(.../verif)	(revision 0)
@@ -0,0 +1,354 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_seq_lib.sv
+// Author: bhunter
+/* About:  [description]
+ *************************************************************************/
+
+`ifndef __ALU_SEQ_LIB_SV__
+   `define __ALU_SEQ_LIB_SV__
+
+   `include "alu_item.sv"
+
+// Forward declaration of library sequence
+typedef class lib_seq_c;
+
+// Forward declaration of sequencer
+typedef class sqr_c;
+   
+//****************************************************************************************
+// class: exer_seq_c
+// Runs <count> transactions
+class exer_seq_c extends uvm_sequence #(item_c);
+   `uvm_object_utils_begin(alu_pkg::exer_seq_c)
+      `uvm_field_int(count, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+   `uvm_add_to_seq_lib(exer_seq_c, lib_seq_c);
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: count
+   // The number of random transactions to perform
+   rand int count;
+   constraint reasonable_cnstr { count inside {[1:100]}; }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+
+   function new(string name="alu_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      item_c item;
+
+      repeat(count) begin
+         `uvm_do(item)
+         get_response(rsp);
+         `cn_info(("Got response result: %08X", rsp.result))
+      end
+   endtask
+endclass : exer_seq_c
+
+//****************************************************************************************
+// class: factorial_seq_c
+// Computes the factorial of a random number, operand
+class factorial_seq_c extends uvm_sequence #(item_c);
+   `uvm_object_utils_begin(alu_pkg::factorial_seq_c)
+      `uvm_field_int(operand, UVM_ALL_ON)
+      `uvm_field_int(result,  UVM_ALL_ON)
+   `uvm_object_utils_end
+   `uvm_add_to_seq_lib(factorial_seq_c, lib_seq_c);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: operand
+   // The value to perform the factorial on
+   rand bit [15:0] operand;
+   constraint operand_cnstr { operand <= 9; }
+
+   // var: result
+   // The final result
+   result_t result = 1;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="factorial_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   // Loop from 1..operand and multiply all the numbers together
+   virtual task body();
+      item_c item;
+      byte num;
+
+      for(num = 1; num <= operand; num++) begin
+         `uvm_do_with(item, { operation == MUL_A_B; alpha == num; beta == local::result[15:0]; })
+         get_response(rsp);
+         result = rsp.result;
+         `cn_info(("num=%0d, result=%0d", num, result))
+      end
+      `cn_info(("%0d! = %0d", operand, result))
+   endtask : body
+endclass : factorial_seq_c
+
+//****************************************************************************************
+// class: summation_seq_c
+// Sends in ALU transactions that add up the values from op_x to op_y, storing the final answer in
+// result
+class summation_seq_c extends uvm_sequence #(item_c);
+   `uvm_object_utils_begin(alu_pkg::summation_seq_c)
+      `uvm_field_int(op_x, UVM_ALL_ON | UVM_DEC)
+      `uvm_field_int(op_y, UVM_ALL_ON | UVM_DEC)
+      `uvm_field_int(result, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+   `uvm_add_to_seq_lib(summation_seq_c, lib_seq_c);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // vars: op_x, op_y
+   // Operands for this summation function
+   rand bit [15:0] op_x;
+   rand bit [15:0] op_y;
+
+   constraint operands_cnstr { op_x < op_y; }
+   constraint reasonable_cnstr {
+      op_x inside {[1:20]};
+      op_y inside {[1:20]};
+   }
+
+   // var: result
+   // The final result
+   result_t result = 0;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="summation_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   // Loop from x..y, adding them up
+   virtual task body();
+      item_c item;
+      byte num;
+      lock();
+      `uvm_do_with(item, { operation == CLR_RES; })
+      get_response(rsp);
+      for(num = op_x; num <= op_y; num++) begin
+         `uvm_do_with(item, {
+            operation == ACCUM;
+            alpha == num;
+         })
+         get_response(rsp);
+      end
+      result = rsp.result;
+      unlock();
+   endtask : body
+endclass : summation_seq_c
+
+//****************************************************************************************
+// class: sum_array_seq_c
+class sum_array_seq_c extends uvm_sequence #(item_c);
+   `uvm_object_utils_begin(alu_pkg::sum_array_seq_c)
+      `uvm_field_array_int(data, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+   `uvm_add_to_seq_lib(sum_array_seq_c, lib_seq_c);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: data
+   // An array of words to be summed
+   rand bit [15:0] data[];
+
+   // keep it to a reasonable size
+   constraint data_cnstr { data.size() inside {[1:50]}; }
+
+   // var: result
+   // The final answer
+   result_t result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+
+   function new(string name="sum_array_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      item_c item;
+      result_t exp_result = data.sum();
+
+      lock();
+      `uvm_do_with(item, { operation == CLR_RES; })
+      get_response(rsp);
+      foreach(data[x]) begin
+         `uvm_do_with(item, { operation == ACCUM; alpha == data[x]; })
+         get_response(rsp);
+      end
+      unlock();
+      result = rsp.result;
+      `cn_info(("Sum of this array = %0x:", result))
+
+      if(result != exp_result)
+        `cn_err(("The result %0x did not match the expected value %0x.", result,
+                 exp_result))
+
+    endtask : body
+endclass : sum_array_seq_c
+
+//****************************************************************************************
+// class: sum_of_factorials_seq_c
+class sum_of_factorials_seq_c extends uvm_sequence #(item_c);
+   `uvm_object_utils_begin(alu_pkg::sum_of_factorials_seq_c)
+      `uvm_field_int(op_x, UVM_ALL_ON | UVM_DEC)
+      `uvm_field_int(op_y, UVM_ALL_ON | UVM_DEC)
+      `uvm_field_int(result, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+   `uvm_add_to_seq_lib(sum_of_factorials_seq_c, lib_seq_c);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // vars: op_x, op_y
+   // Operands for this summation function
+   rand bit [15:0] op_x;
+   rand bit [15:0] op_y;
+
+   constraint operands_cnstr {
+      op_x < op_y;
+      op_x inside {[1:8]};
+      op_y inside {[1:8]};
+   }
+
+   // var: result
+   // The final result
+   result_t result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="sum_of_factorials_array_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      int num;
+      bit [15:0] data[];
+      factorial_seq_c fact_seq;
+      sum_array_seq_c sum_seq;
+      int  idx;
+
+      // fill the data array with all the factorials
+      data = new[(op_y - op_x + 1)];
+      idx = 0;
+      for(num = op_x; num <= op_y; num++) begin
+         `uvm_do_with(fact_seq, { operand == num; })
+         data[idx] = fact_seq.result;
+         idx++;
+      end
+
+      // now sum the array
+      `uvm_create(sum_seq)
+      sum_seq.data = data;
+      `uvm_send(sum_seq)
+      result = sum_seq.result;
+      `cn_info(("The sum of factorials from %0d to %0d is %0d.",
+                op_x, op_y, result))
+   endtask : body
+endclass : sum_of_factorials_seq_c
+
+//****************************************************************************************
+class sor_clr_seq_c extends uvm_sequence#(item_c);
+   `uvm_object_utils(alu_pkg::sor_clr_seq_c)
+   `uvm_declare_p_sequencer(sqr_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="sor_clr_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      result_t accum_result = 0;
+      result_t new_result;
+      uvm_status_e status;
+      uvm_reg result_reg = p_sequencer.reg_block.ALU_RESULT;
+      uvm_reg_data_t sor_value;
+
+      forever begin
+         // get the next monitored transaction and add it to the accumulated results
+         p_sequencer.monitored_result_mbox.get(new_result);
+         accum_result += new_result;
+         `cn_dbg(30, ("accum_result = %8X", accum_result))
+
+         if(accum_result >= 32'h100_0000) begin
+            grab();
+            result_reg.read(status, sor_value);
+
+            // ensure status was ok
+            if(status == UVM_NOT_OK) begin
+               `cn_err(("Unable to read from ALU_RESULT register."))
+            end else begin
+               // ensure that current value exceeds 'h100_0000
+               `cn_dbg(30, ("SOR read as %08X", sor_value))
+               if(sor_value < 'h100_0000)
+                 `cn_err(("Read from ALU_RESULT[SOR] but its value was %08X", sor_value))
+
+               // clear out accum_result
+               accum_result = 0;
+
+               // empty out mailbox in case any have been added since the read started
+               while(p_sequencer.monitored_result_mbox.try_get(new_result))
+                  ;
+            end
+            ungrab();
+         end
+      end
+   endtask : body
+endclass : sor_clr_seq_c
+   
+//****************************************************************************************
+class lib_seq_c extends uvm_sequence_library #(item_c);
+   `uvm_object_utils(alu_pkg::lib_seq_c)
+   `uvm_sequence_library_utils(lib_seq_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="lib_seq");
+      super.new(name);
+      init_sequence_library();
+   endfunction : new
+
+endclass : lib_seq_c
+   
+
+`endif // __ALU_SEQ_LIB_SV__
+   
\ No newline at end of file
Index: verif/vkits/alu/alu_cfg.sv
===================================================================
--- verif/vkits/alu/alu_cfg.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_cfg.sv	(.../verif)	(revision 0)
@@ -0,0 +1,50 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_cfg.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_CFG_SV__
+   `define __ALU_CFG_SV__
+
+// class: cfg_c
+// ALU vkit's cfg class
+class cfg_c extends uvm_object;
+   `uvm_object_utils_begin(alu_pkg::cfg_c)
+      `uvm_field_int(drv_inter_item_delay, UVM_DEFAULT | UVM_DEC)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: drv_inter_item_delay
+   // How long the driver should wait (in clocks) after sending an item
+   rand int unsigned drv_inter_item_delay;
+   constraint drv_delay_cnstr {
+      drv_inter_item_delay < 20;
+   }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="cfg");
+      super.new(name);
+   endfunction : new
+
+endclass : cfg_c
+
+`endif // __ALU_CFG_SV__
+
Index: verif/vkits/alu/alu_intf.sv
===================================================================
--- verif/vkits/alu/alu_intf.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_intf.sv	(.../verif)	(revision 0)
@@ -0,0 +1,104 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_intf.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_INTF_SV__
+   `define __ALU_INTF_SV__
+
+// class: alu_intf
+interface alu_intf(input logic clk,
+                   input logic rst_n);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Signals
+
+   // var: ctl
+   // Asserted only on the first cycle of a new transaction, while dat contains the operation
+   logic        ctl;
+
+   // var: dat
+   // The input data nibble that contains the operation and operands
+   logic [7:0]  dat;
+
+   // var: ready
+   // The output of the ALU that indicates when the result data is valid
+   logic        ready;
+
+   // var: result
+   // The 32-bit result data
+   logic [31:0] result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Clocking blocks
+
+   // var: drv_cb
+   // A clocking block that represents how the environment's driver sees the interface
+   clocking drv_cb @(posedge clk);
+      output    ctl;
+      output    dat;
+      input     ready;
+      input     result;
+      input     rst_n;
+   endclocking : drv_cb
+
+   // var: mon_cb
+   // A clocking block that represents how the environment's monitor sees the interface
+   clocking mon_cb @(posedge clk);
+      input     ctl;
+      input     dat;
+      input     ready;
+      input     result;
+      input     rst_n;
+   endclocking : mon_cb
+
+   //----------------------------------------------------------------------------------------
+   // Group: Modports
+
+   modport drv_mp(clocking drv_cb,
+                  import reset);
+   modport mon_mp(clocking mon_cb);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+
+   // func: reset
+   // Convenience function for the driver to reset its outputs
+   function void reset();
+      ctl = 0;
+      dat = 8'b0;
+   endfunction : reset
+
+   //----------------------------------------------------------------------------------------
+   // Group: Assertions
+
+   // Ensure that no signals are ever an X when they shouldn't be
+   always @(posedge clk) begin
+      if(rst_n) begin
+         assert(!$isunknown(ctl)) else `cn_err_intf(("Signal ctl is an X."))
+         assert(!$isunknown(dat)) else `cn_err_intf(("Signal dat is an X."))
+         assert(!$isunknown(ready)) else `cn_err_intf(("Signal ready is an X."))
+         if(ready)
+            assert(!$isunknown(result)) else `cn_err_intf(("Signal result is an X."))
+      end
+   end
+
+endinterface : alu_intf
+
+`endif // __ALU_INTF_SV__
+   
\ No newline at end of file
Index: verif/vkits/alu/alu_pkg.sv
===================================================================
--- verif/vkits/alu/alu_pkg.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_pkg.sv	(.../verif)	(revision 0)
@@ -0,0 +1,57 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_pkg.sv
+// Author: bhunter
+/* About:  alu package
+ *************************************************************************/
+
+
+// (`includes of macros may go here)
+`include "uvm_macros.svh"
+
+// package: alu_pkg
+// (Describe me)
+package alu_pkg;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Types
+   typedef logic [31:0] result_t;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Imports
+   import uvm_pkg::*;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Imp Declarations
+
+   `uvm_analysis_imp_decl(_item)
+   `uvm_analysis_imp_decl(_result)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Includes
+
+`include "alu_agent.sv"
+`include "alu_cfg.sv"
+`include "alu_drv.sv"
+`include "alu_item.sv"
+`include "alu_mon.sv"
+`include "alu_pred.sv"
+`include "alu_seq_lib.sv"
+`include "alu_sqr.sv"
+   
+endpackage : alu_pkg
+   
+
Index: verif/vkits/alu/alu_sqr.sv
===================================================================
--- verif/vkits/alu/alu_sqr.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alu/alu_sqr.sv	(.../verif)	(revision 0)
@@ -0,0 +1,86 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alu_sqr.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_SQR_SV__
+   `define __ALU_SQR_SV__
+
+   `include "alu_item.sv"
+   `include "alu_seq_lib.sv"
+
+// class: sqr_c
+class sqr_c extends uvm_sequencer#(item_c);
+   `uvm_component_utils_begin(alu_pkg::sqr_c)
+      `uvm_field_object(reg_block, UVM_REFERENCE)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   // var: reg_block
+   // Auto-generated Register block
+   alu_csr_pkg::alu_ncb_reg_block_c reg_block;
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   // var: monitored_result_imp
+   // Received all monitored results 
+   uvm_analysis_imp #(result_t, sqr_c) monitored_result_imp;
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: monitored_result_mbox
+   // A holding place until the sequence fetches from here
+   mailbox #(result_t) monitored_result_mbox;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="sqr",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      monitored_result_imp = new("monitored_result_imp", this);
+      monitored_result_mbox = new();
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      sor_clr_seq_c sor_clr_seq = sor_clr_seq_c::type_id::create("sor_clr_seq");
+      sor_clr_seq.start(this);
+   endtask : run_phase
+
+   ////////////////////////////////////////////
+   // func: write
+   // Receives monitored results from the imp
+   virtual function void write(result_t _result);
+      monitored_result_mbox.try_put(_result);
+      `cn_info(("Received result %08X", _result))
+   endfunction : write
+endclass : sqr_c
+   
+`endif // __ALU_SQR_SV__
+   
\ No newline at end of file
Index: verif/vkits/frm/frm_vseq_lib.sv
===================================================================
--- verif/vkits/frm/frm_vseq_lib.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/vkits/frm/frm_vseq_lib.sv	(.../verif)	(working copy)
@@ -22,14 +22,9 @@
    `define __FRM_VSEQ_LIB_SV__
 
 
-// 
-// UNCOMMENT THE FOLLOWING FOR PROBLEM 14-1:
-//
-
-/* -----\/----- EXCLUDED -----\/-----
 `include "frm_vsqr.sv"
 
-//-****************************************************************************************
+//****************************************************************************************
 // class: basic_vseq_c
 class basic_vseq_c extends uvm_sequence;
    `uvm_object_utils(frm_pkg::basic_vseq_c)
@@ -63,7 +58,92 @@
    endtask : body
 
 endclass : basic_vseq_c
- -----/\----- EXCLUDED -----/\----- */
 
+//****************************************************************************************
+// class: basic_delay_vseq_c
+// Let the frame sometimes precede the ALU transactions
+class basic_delay_vseq_c extends uvm_sequence;
+   `uvm_object_utils(frm_pkg::basic_delay_vseq_c)
+   `uvm_declare_p_sequencer(vsqr_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // frame_delay_ns
+   // Delay of sending the frame, with respect to starting the ALU transactions
+   // If frame_delay_ns is negative, then send the frame first, otherwise, send transactions first
+   rand int frame_delay_ns;
+   constraint frame_delay_cnstr { frame_delay_ns inside {[-100:100]}; }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="basic_delay_vseq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      frame_c frame;
+      alu_pkg::exer_seq_c alu_exer_seq;
+
+      // create and randomize to see how many ALU transactions to send
+      `uvm_create_on(frame, p_sequencer.frm_sqr)
+      frame.randomize();
+
+      `cn_info(("Sending this frame: %s", frame.convert2string()))
+
+      fork
+         begin
+            if(frame_delay_ns > 0)
+               #(frame_delay_ns * 1ns);
+            `uvm_send(frame);
+            get_response(rsp);
+            `cn_info(("Frame completed: %s", rsp.convert2string()))
+         end
+
+         begin
+            if(frame_delay_ns < 0)
+               #((-frame_delay_ns) * 1ns);
+            `uvm_do_on_with(alu_exer_seq, p_sequencer.alu_sqr, { count == frame.frame_len; })
+         end
+      join
+
+   endtask : body
+endclass : basic_delay_vseq_c
+
+//****************************************************************************************
+// class: exer_vseq_c
+// Executes a random number of basic_delay_vseq_c
+class exer_vseq_c extends uvm_sequence;
+   `uvm_object_utils_begin(frm_pkg::exer_vseq_c)
+      `uvm_field_int(count, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: count
+   // The number of basic_vseq to do
+   rand int count;
+   constraint count_cnstr { count inside {[20:100]}; }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="exer_vseq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      basic_delay_vseq_c vseq;
+      `cn_seq_raise
+      `cn_info(("Transmitting %0d frames.", count))
+      repeat(count)
+         `uvm_do(vseq)
+      `cn_seq_drop
+   endtask : body
+endclass : exer_vseq_c
+
 `endif // __FRM_VSEQ_LIB_SV__
-   
\ No newline at end of file
Index: verif/vkits/frm/frm_env.sv
===================================================================
--- verif/vkits/frm/frm_env.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/vkits/frm/frm_env.sv	(.../verif)	(working copy)
@@ -23,6 +23,7 @@
    
 `include "frm_agent.sv"
 `include "frm_frame.sv"
+`include "frm_vsqr.sv"
 
 // class: env_c
 // FRM Testbench Environment
@@ -67,6 +68,10 @@
    // The FRM agent
    agent_c frm_agent;
 
+   // var: vsqr
+   // The virtual sequencer
+   vsqr_c vsqr;
+   
    //----------------------------------------------------------------------------------------
    // Methods
    function new(string name="env",
@@ -101,12 +106,21 @@
       uvm_config_db#(uvm_object)::set(this, "*",              "alutb_reg_block", reg_block);
       uvm_config_db#(uvm_object)::set(this, "alu_agent", "cfg", cfg.alu_cfg);
       alu_agent = alu_pkg::agent_c::type_id::create("alu_agent", this);
+
+      // create the virtual sequencer
+      vsqr = vsqr_c::type_id::create("vsqr", this);
    endfunction : build_phase
 
    ////////////////////////////////////////////
    // func: connect_phase
    virtual function void connect_phase(uvm_phase phase);
       super.connect_phase(phase);
+
+      if(!frm_agent.sqr || !alu_agent.sqr)
+         `cn_fatal(("frame_agent.sqr or alu_agent.sqr are not present!"))
+
+      vsqr.frm_sqr = frm_agent.sqr;
+      vsqr.alu_sqr = alu_agent.sqr;
    endfunction : connect_phase
 
 endclass : env_c
Index: verif/vkits/frm/frm_vsqr.sv
===================================================================
--- verif/vkits/frm/frm_vsqr.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/frm/frm_vsqr.sv	(.../verif)	(revision 0)
@@ -0,0 +1,59 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   frm_vsqr.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __FRM_VSQR_SV__
+   `define __FRM_VSQR_SV__
+
+`include "frm_sqr.sv"
+
+// class: vsqr_c
+// Virtual sequencer holding references to frm_sqr and alu_sqr
+class vsqr_c extends uvm_sequencer;
+   `uvm_component_utils_begin(frm_pkg::vsqr_c)
+      `uvm_field_object(frm_sqr,         UVM_REFERENCE)
+      `uvm_field_object(alu_sqr,         UVM_REFERENCE)
+      `uvm_field_object(reg_block,       UVM_REFERENCE)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Sequencer references
+
+   // var: frm_sqr
+   sqr_c frm_sqr;
+
+   // var: alu_sqr
+   alu_pkg::sqr_c alu_sqr;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: reg_block
+   // alutb register block (reference to the one in cfg)
+   alu_csr_pkg::alu_ncb_reg_block_c reg_block;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="vsqr",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+endclass : vsqr_c
+   
+`endif // __FRM_VSQR_SV__
Index: verif/vkits/frm/frm_pkg.sv
===================================================================
--- verif/vkits/frm/frm_pkg.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/vkits/frm/frm_pkg.sv	(.../verif)	(working copy)
@@ -40,6 +40,7 @@
 `include "frm_seq_lib.sv"
 `include "frm_sqr.sv"
 `include "frm_vseq_lib.sv"
+`include "frm_vsqr.sv"
    
 endpackage : frm_pkg
    
Index: verif/vkits/alutb/alutb_pkg.sv
===================================================================
--- verif/vkits/alutb/alutb_pkg.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/vkits/alutb/alutb_pkg.sv	(.../verif)	(working copy)
@@ -31,9 +31,11 @@
 
    //----------------------------------------------------------------------------------------
    // Group: Includes
+
+`include "alutb_alu_item_subscriber.sv"
 `include "alutb_cfg.sv"
 `include "alutb_env.sv"
-
+   
 endpackage : alutb_pkg
    
 
Index: verif/vkits/alutb/alutb_alu_item_subscriber.sv
===================================================================
--- verif/vkits/alutb/alutb_alu_item_subscriber.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/vkits/alutb/alutb_alu_item_subscriber.sv	(.../verif)	(revision 0)
@@ -0,0 +1,45 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   alutb_alu_item_subscriber.sv
+// Author: bhunter
+/* About:  Listens for all monitored ALU transactions.
+ *************************************************************************/
+
+`ifndef __ALUTB_ALU_ITEM_SUBSCRIBER_SV__
+   `define __ALUTB_ALU_ITEM_SUBSCRIBER_SV__
+
+// class: alu_item_subscriber_c
+// Print out all ALU transactions.
+class alu_item_subscriber_c extends uvm_subscriber#(alu_pkg::item_c);
+   `uvm_component_utils(alutb_pkg::alu_item_subscriber_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="alu_item_subscriber",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: write
+   // Receives the alu_pkg::item_c
+   virtual function void write(alu_pkg::item_c t);
+      `cn_info(("Received this ALU transaction: %s", t.convert2string()))
+   endfunction : write
+endclass : alu_item_subscriber_c
+   
+`endif // __ALUTB_ALU_ITEM_SUBSCRIBER_SV__
+   
\ No newline at end of file
Index: verif/vkits/alutb/alutb_env.sv
===================================================================
--- verif/vkits/alutb/alutb_env.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/vkits/alutb/alutb_env.sv	(.../verif)	(working copy)
@@ -24,6 +24,7 @@
 
    `include "alutb_cfg.sv"
    `include "alutb_reg_block.sv"
+   `include "alutb_alu_item_subscriber.sv"
 
 // class: env_c
 // ALUTB Environment class
@@ -60,6 +61,14 @@
    // The ncb env
    ncb_pkg::env_c ncb_env;
 
+   // var: alu_agent
+   // The ALU agent
+   alu_pkg::agent_c alu_agent;
+
+   // var: alu_item_subscriber
+   // Prints out all items seen from the ALU agent
+   alu_item_subscriber_c alu_item_subscriber;
+   
    //----------------------------------------------------------------------------------------
    // Group: Methods
    function new(string name="env",
@@ -86,12 +95,21 @@
 
       uvm_config_db#(uvm_object)::set(this, "ncb_env", "cfg", ncb_cfg);
       ncb_env = ncb_pkg::env_c::type_id::create("ncb_env", this);
+
+      // create the ALU agent
+      uvm_config_db#(int)::set(this, "alu_agent", "is_active", is_active);
+      uvm_config_db#(uvm_object)::set(this, "alu_agent", "cfg", cfg.alu_cfg);
+      alu_agent = alu_pkg::agent_c::type_id::create("alu_agent", this);
+
+      alu_item_subscriber = alu_item_subscriber_c::type_id::create("alu_item_subscriber", this);
    endfunction : build_phase
 
    ////////////////////////////////////////////
    // func: connect_phase
    virtual function void connect_phase(uvm_phase phase);
       super.connect_phase(phase);
+
+      alu_agent.monitored_item_port.connect(alu_item_subscriber.analysis_export);
    endfunction : connect_phase
 
    ////////////////////////////////////////////
Index: verif/vkits/alutb/alutb_cfg.sv
===================================================================
--- verif/vkits/alutb/alutb_cfg.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 104137)
+++ verif/vkits/alutb/alutb_cfg.sv	(.../verif)	(working copy)
@@ -30,8 +30,13 @@
    //----------------------------------------------------------------------------------------
    // Group: Types
 
+   // enum: alu_const_knob_e
+   // Used to constrain the K and C values for ALU
+   typedef enum { INNOCUOUS, SMALL, LARGE, XLARGE, UNLIMITED } alu_const_knob_e;
+
    `uvm_object_utils_begin(alutb_pkg::cfg_c)
       `uvm_field_object(reg_block, UVM_REFERENCE)
+      `uvm_field_enum(alu_const_knob_e, alu_const_knob, UVM_ALL_ON)
    `uvm_object_utils_end
 
    //----------------------------------------------------------------------------------------
@@ -41,19 +46,42 @@
    // Register block for this environment
    rand alu_csr_pkg::alu_ncb_reg_block_c reg_block;
 
-   constraint innocuous_cnstr {
-      reg_block.ALU_CONST.K_VAL.value == 1;
-      reg_block.ALU_CONST.C_VAL.value == 0;
+   // var: alu_const_knob
+   // Constrains the K_VAL and C_VAL
+   rand alu_const_knob_e alu_const_knob;
+   constraint const_knob_cnstr { alu_const_knob == INNOCUOUS; }
+
+   // constrain K_VAL based on alu_const_knob
+   constraint kval_cnstr {
+      alu_const_knob == INNOCUOUS -> (reg_block.ALU_CONST.K_VAL.value == 1);
+      alu_const_knob == SMALL     -> (reg_block.ALU_CONST.K_VAL.value inside {[2:5]});
+      alu_const_knob == LARGE     -> (reg_block.ALU_CONST.K_VAL.value inside {[6:50]});
+      alu_const_knob == XLARGE    -> (reg_block.ALU_CONST.K_VAL.value inside {[51:255]});
+      alu_const_knob == UNLIMITED -> (reg_block.ALU_CONST.K_VAL.value inside {[0:255]});
    }
 
+   // constrain C_VAL based on alu_const_knob
+   constraint cval_cnstr {
+      alu_const_knob == INNOCUOUS -> (reg_block.ALU_CONST.C_VAL.value == 0);
+      alu_const_knob == SMALL     -> (reg_block.ALU_CONST.C_VAL.value inside {[2:10]});
+      alu_const_knob == LARGE     -> (reg_block.ALU_CONST.C_VAL.value inside {[11:128]});
+      alu_const_knob == XLARGE    -> (reg_block.ALU_CONST.C_VAL.value inside {[129:255]});
+      alu_const_knob == UNLIMITED -> (reg_block.ALU_CONST.C_VAL.value inside {[0:255]});
+   }
+   
    //----------------------------------------------------------------------------------------
    // Group: Fields
 
+   // var: alu_cfg
+   // The ALU vkit's configuration class
+   rand alu_pkg::cfg_c alu_cfg;
+
    //----------------------------------------------------------------------------------------
    // Group: Methods
    function new(string name="cfg");
       super.new(name);
       cg = new();
+      alu_cfg = alu_pkg::cfg_c::type_id::create("alu_cfg");
    endfunction : new
 
    //----------------------------------------------------------------------------------------

Property changes on: verif/frm
___________________________________________________________________
Added: svn:ignore
   + .make_history
.pid_history
novas_dump.log
obj
sim
ucli.key


Index: verif/frm/rtl.flist
===================================================================
--- verif/frm/rtl.flist	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/rtl.flist	(.../verif)	(revision 0)
@@ -0,0 +1,9 @@
++incdir+../../rtl/include
++incdir+../../rtl/mio
+-y ../../verif/hdl
+-y ../../rtl/bist
+-y ../../rtl/ecc
+-y ../../rtl/common
+-y ../../rtl/mio
+-y ../../rtl/mem
+-y ../../rtl/alu
Index: verif/frm/frm_tb_top.sv
===================================================================
--- verif/frm/frm_tb_top.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/frm_tb_top.sv	(.../verif)	(revision 0)
@@ -0,0 +1,93 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   frm_tb_top.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+import uvm_pkg::*;
+
+// package: frm_tb_top
+// Top-level testbench
+module frm_tb_top;
+   //----------------------------------------------------------------------------------------
+   // Group: Interfaces
+
+   // obj: tb_clk_i
+   // Testbench clock interface
+   cn_clk_intf tb_clk_i();
+   wire tb_clk = tb_clk_i.clk;
+
+   // obj: tb_rst_i
+   // Testbench reset interface
+   cn_rst_intf tb_rst_i();
+   wire tb_rst_n = tb_rst_i.rst_n;
+   
+   // obj: frm_i
+   // The frm_intf instance.
+   frm_intf frm_i(.clk(tb_clk),
+                  .rst_n(tb_rst_n));
+   
+   // obj: ncb_i
+   // The <ncb_intf> instance.
+   ncb_intf ncb_i(.clk(tb_clk), .reset_n(tb_rst_n));
+
+   // obj: alu_i
+   // The <alu_intf> instance
+   alu_intf alu_i(.clk(tb_clk), .rst_n(tb_rst_n));
+
+   //----------------------------------------------------------------------------------------
+   // Group: DUT
+   // (Instantiate the DUT and other modules here)
+   alu_wrapper alu_wrapper(/*AUTOINST*/
+                           // Interfaces
+                           .ncb_i               (ncb_i),
+                           .alu_i               (alu_i),
+                           .frm_i               (frm_i),
+                           // Inputs
+                           .tb_clk              (tb_clk),
+                           .tb_rst_n            (tb_rst_n));
+
+   //----------------------------------------------------------------------------------------
+   // Group: Procedural Blocks
+   function void pre_run_test();
+      `cn_set_intf(virtual cn_clk_intf    , "cn_pkg::clk_intf" , "tb_clk_vi", tb_clk_i);
+      `cn_set_intf(virtual cn_rst_intf    , "cn_pkg::rst_intf" , "tb_rst_vi", tb_rst_i);
+      `cn_set_intf(virtual ncb_intf       , "ncb_pkg::intf"    , "ncb_vi"   , ncb_i);
+      `cn_set_intf(virtual alu_intf.drv_mp, "alu_pkg::alu_intf", "drv_vi"   , alu_i.drv_mp)
+      `cn_set_intf(virtual alu_intf.mon_mp, "alu_pkg::alu_intf", "mon_vi"   , alu_i.mon_mp)
+      `cn_set_intf(virtual frm_intf.drv_mp, "frm_pkg::frm_intf", "drv_vi"   , frm_i.drv_mp);
+      `cn_set_intf(virtual frm_intf.mon_mp, "frm_pkg::frm_intf", "mon_vi"   , frm_i.mon_mp);
+   endfunction : pre_run_test
+
+   // proc: Reset Busses
+   // Clear the ncb/rsl blocks
+   initial begin
+      // clear out the ncb
+      ncb_i.reset();
+      alu_i.reset();
+      frm_i.reset();
+   end
+   
+   `include "tbv_common.v"
+endmodule : frm_tb_top
+
+// Local Variables:
+// verilog-library-extensions:(".v" ".sv" ".svh")
+// verilog-library-directories:("." "../../rtl/include/" "../common" "../vkits/frm" "../hdl")
+// verilog-auto-ignore-concat:t
+// End:
+   
\ No newline at end of file
Index: verif/frm/tests/base_test.sv
===================================================================
--- verif/frm/tests/base_test.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/tests/base_test.sv	(.../verif)	(revision 0)
@@ -0,0 +1,158 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   base_test.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __BASE_TEST_SV__
+   `define __BASE_TEST_SV__
+
+// class: base_test_c
+class base_test_c extends uvm_test;
+   `uvm_component_utils_begin(base_test_c)
+      `uvm_field_object(cfg, UVM_ALL_ON)
+      `uvm_field_object(reg_block, UVM_ALL_ON)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: cfg
+   // The configuration class
+   frm_pkg::cfg_c cfg;
+
+   // var: reg_block
+   // The register block (reference to the one in cfg)
+   alu_csr_pkg::alu_ncb_reg_block_c reg_block;
+
+   // var: env
+   // The frm environment
+   frm_pkg::env_c env;
+   
+   // var: tb_clk_drv
+   // The testbench clock driver
+   cn_pkg::clk_drv_c tb_clk_drv;
+
+   // var: tb_rst_drv
+   // The testbench reset driver
+   cn_pkg::rst_drv_c tb_rst_drv;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+  
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="base_test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      // Create the global environment        
+      global_pkg::env = global_pkg::env_c::type_id::create("global_env", this);
+
+      // create the random configurations
+      cfg = frm_pkg::cfg_c::type_id::create("cfg");
+   
+      // create reg_block
+      if(reg_block == null) begin
+         reg_block = alu_csr_pkg::alu_ncb_reg_block_c::type_id::create("reg_block", this);
+         reg_block.build();
+         reg_block.lock_model();
+      end
+
+      // randomize configs & CSRs
+      cfg.reg_block = reg_block;
+
+      // randomize the cfg and CSR fields
+      randomize_cfg();
+      
+      uvm_config_db#(uvm_object)::set(this, "*", "reg_block", reg_block);
+      uvm_config_db#(uvm_object)::set(this, "*", "cfg",       cfg      );
+
+      // set up the frm env
+      uvm_config_db#(string)::set(this, "env.ncb_env",    "intf_name",    "ncb_vi");
+      env = frm_pkg::env_c::type_id::create("env", this);
+
+      // Not randomized by default.  Derived tests can randomize in end_of_elaboration_phase.
+      // Create the clock driver
+      uvm_config_db#(string)::set(this, "tb_clk_drv", "intf_name", "tb_clk_vi");
+      uvm_config_db#(int)::set(this, "tb_clk_drv", "period_ps", 2000);
+      tb_clk_drv = cn_pkg::clk_drv_c::type_id::create("tb_clk_drv", this);
+
+      // Create the reset driver
+      uvm_config_db#(string)::set(this,"tb_rst_drv", "intf_name",     "tb_rst_vi");
+      uvm_config_db#(int)::set(this, "tb_rst_drv", "reset_time_ps", 20000);
+      tb_rst_drv = cn_pkg::rst_drv_c::type_id::create("tb_rst_drv", this);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+
+      if(reg_block.get_parent() == null) begin
+         ncb_pkg::reg_adapter_c ncb_adapter =
+            ncb_pkg::reg_adapter_c::type_id::create("ncb_reg_adapter", , get_full_name());
+         reg_block.ncb_map.set_sequencer(env.ncb_env.outb_agent.sqr, ncb_adapter);
+         reg_block.ncb_map.set_auto_predict(1);
+      end
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      super.run_phase(phase);
+   endtask : run_phase
+
+
+   ////////////////////////////////////////////
+   virtual task configure_phase(uvm_phase phase);
+      uvm_status_e status;
+
+      phase.raise_objection(this);
+      
+      reg_block.update(status);
+      // (alternatively, start a configuration sequence)
+
+      // ensure that all transactions complete
+      #(100ns);
+      
+      phase.drop_objection(this);
+   endtask : configure_phase
+
+   ////////////////////////////////////////////
+   virtual function void randomize_cfg();
+      randomize(cfg);
+   endfunction : randomize_cfg
+   
+endclass : base_test_c
+   
+`endif // __BASE_TEST_SV__
+   
\ No newline at end of file
Index: verif/frm/tests/basic.sv
===================================================================
--- verif/frm/tests/basic.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/tests/basic.sv	(.../verif)	(revision 0)
@@ -0,0 +1,49 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// * CAVIUM CONFIDENTIAL                                                 
+// *                                                                     
+// *                         PROPRIETARY NOTE                            
+// *                                                                     
+// * This software contains information confidential and proprietary to  
+// * Cavium, Inc. It shall not be reproduced in whole or in part, or     
+// * transferred to other documents, or disclosed to third parties, or   
+// * used for any purpose other than that for which it was obtained,     
+// * without the prior written consent of Cavium, Inc.                   
+// * (c) 2012, Cavium, Inc.  All rights reserved.                      
+// * (utg v0.7.1)
+// ***********************************************************************
+// File:   basic.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __BASIC_SV__
+   `define __BASIC_SV__
+   
+   `include "base_test.sv"
+
+// class: basic_test_c
+// (Describe me)
+class basic_test_c extends base_test_c;
+   `uvm_component_utils(basic_test_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      uvm_config_db#(uvm_object_wrapper)::set(this, "env.vsqr.main_phase",
+                                              "default_sequence",
+                                              frm_pkg::exer_vseq_c::type_id::get());
+   endfunction : build_phase
+endclass : basic_test_c
+   
+`endif // __BASIC_SV__
+      
\ No newline at end of file
Index: verif/frm/frm.flist
===================================================================
--- verif/frm/frm.flist	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/frm.flist	(.../verif)	(revision 0)
@@ -0,0 +1,10 @@
++incdir+../../verif/frm
++incdir+../../verif/common
++incdir+../../verif/uvm_common
++incdir+../../verif/hdl
++incdir+../../verif/frm/tests
+../../verif/frm/frm_tb_top.sv
+../../verif/frm/alu_wrapper.sv
+../../verif/frm/tests/basic.sv
+../../verif/frm/tests/base_test.sv
+
Index: verif/frm/alu_wrapper.sv
===================================================================
--- verif/frm/alu_wrapper.sv	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/alu_wrapper.sv	(.../verif)	(revision 0)
@@ -0,0 +1,161 @@
+module alu_wrapper(input logic tb_clk,
+                   tb_rst_n,
+                   ncb_intf ncb_i,
+                   alu_intf alu_i,
+                   frm_intf frm_i);
+   
+   /*AUTOREGINPUT*/
+   // Beginning of automatic reg inputs (for undeclared instantiated-module inputs)
+   reg                  erst_0a_n;              // To dut of alu.v
+   reg [1:0]            fus__ema;               // To dut of alu.v
+   reg                  mio__clear_bist;        // To dut of alu.v
+   reg                  mio__start_bist;        // To dut of alu.v
+   reg                  pi_chip_reset_n;        // To dut of alu.v
+   reg                  qlm0__ref_clk;          // To dut of alu.v
+   reg                  qlm1__ref_clk;          // To dut of alu.v
+   reg                  qlm2__ref_clk;          // To dut of alu.v
+   reg                  qlm3__ref_clk;          // To dut of alu.v
+   reg                  qlm4__ref_clk;          // To dut of alu.v
+   reg [3:0]            rsl__dbg_offset;        // To dut of alu.v
+   reg                  rst__ciu_prtmode0;      // To dut of alu.v
+   reg                  rst__ciu_prtmode1;      // To dut of alu.v
+   reg                  rst__ciu_rboot;         // To dut of alu.v
+   reg [1:0]            rst__ciu_sft_prst;      // To dut of alu.v
+   reg                  rst__rsl_int;           // To dut of alu.v
+   reg                  srst_cold_n;            // To dut of alu.v
+   reg                  srst_cold_or_warm_n;    // To dut of alu.v
+   reg                  srst_n;                 // To dut of alu.v
+   reg                  start_bist_1a;          // To dut of alu.v
+   // End of automatics
+   /*AUTOWIRE*/
+   // Beginning of automatic wires (for undeclared instantiated-module outputs)
+   wire [16:0]          ciu__dbg_dat;           // From dut of alu.v
+   wire                 ciu__rst_sft_prst0;     // From dut of alu.v
+   wire                 ciu__rst_sft_prst1;     // From dut of alu.v
+   wire                 ciu__rst_sft_rst;       // From dut of alu.v
+   wire                 ciu__rst_wdg_rst;       // From dut of alu.v
+   wire                 mio__npi_csr_credit;    // From dut of alu.v
+   // End of automatics
+
+   // obj: alu
+   /*
+    alu AUTO_TEMPLATE (
+    .alu_\(.*\)         (alu_i.\1[]),
+    .frame              (frm_i.frame),
+    .frame\(.*\)        (frm_i.frame\1[]),
+    
+    .ncb__busy         (ncb_i.outb.outb_bp[0]),
+
+    .ncb__inb_\(.*\)   (ncb_i.inb.\1[]),
+    .ncb__inb_dev_req  (ncb_i.inb.dev_req[0]),
+    .ncb__outb_\(.*\)  (ncb_i.outb.\1[]),
+    .ncb__outb_grant   (ncb_i.inb.grant[6:0]),
+
+    .sclk          (tb_clk),
+    .\(.*\) (\1[]),
+
+    .id__model_speedup   (clear_bist),
+    .mio_fus__authentik_mode (1'b0),
+    .scan_clken           ({1'b0}),
+    .scan_mode           ({1'b0}),
+
+    .ref_clk               (tb_clk),
+    ); */
+   alu dut(/*AUTOINST*/
+           // Outputs
+           .ciu__dbg_dat                (ciu__dbg_dat[16:0]),    // Templated
+           .ciu__rst_sft_prst0          (ciu__rst_sft_prst0),    // Templated
+           .ciu__rst_sft_prst1          (ciu__rst_sft_prst1),    // Templated
+           .ciu__rst_sft_rst            (ciu__rst_sft_rst),      // Templated
+           .ciu__rst_wdg_rst            (ciu__rst_wdg_rst),      // Templated
+           .frame                       (frm_i.frame),           // Templated
+           .frame_bp                    (frm_i.frame_bp),        // Templated
+           .frame_data                  (frm_i.frame_data[31:0]), // Templated
+           .mio__npi_csr_credit         (mio__npi_csr_credit),   // Templated
+           .ncb__busy                   (ncb_i.outb.outb_bp[0]), // Templated
+           .ncb__inb_data               (ncb_i.inb.data[63:0]),  // Templated
+           .ncb__inb_dev_req            (ncb_i.inb.dev_req[0]),  // Templated
+           .ncb__inb_dst                (ncb_i.inb.dst[8:0]),    // Templated
+           .ncb__inb_mask               (ncb_i.inb.mask[7:0]),   // Templated
+           .ncb__inb_opc                (ncb_i.inb.opc[3:0]),    // Templated
+           .ncb__inb_src                (ncb_i.inb.src[7:0]),    // Templated
+           .ncb__inb_valid              (ncb_i.inb.valid),       // Templated
+           .alu_ready                   (alu_i.ready),           // Templated
+           .alu_result                  (alu_i.result[31:0]),    // Templated
+           // Inputs
+           .alu_ctl                     (alu_i.ctl),             // Templated
+           .alu_dat                     (alu_i.dat[7:0]),        // Templated
+           .erst_0a_n                   (erst_0a_n),             // Templated
+           .frame_len                   (frm_i.frame_len[4:0]),  // Templated
+           .frame_len_val               (frm_i.frame_len_val),   // Templated
+           .fus__ema                    (fus__ema[1:0]),         // Templated
+           .mio__clear_bist             (mio__clear_bist),       // Templated
+           .mio__start_bist             (mio__start_bist),       // Templated
+           .ncb__outb_data              (ncb_i.outb.data[63:0]), // Templated
+           .ncb__outb_dst               (ncb_i.outb.dst[7:0]),   // Templated
+           .ncb__outb_eot               (ncb_i.outb.eot),        // Templated
+           .ncb__outb_grant             (ncb_i.inb.grant[6:0]),  // Templated
+           .ncb__outb_mask              (ncb_i.outb.mask[7:0]),  // Templated
+           .ncb__outb_src               (ncb_i.outb.src[8:0]),   // Templated
+           .ncb__outb_valid             (ncb_i.outb.valid),      // Templated
+           .pi_chip_reset_n             (pi_chip_reset_n),       // Templated
+           .qlm0__ref_clk               (qlm0__ref_clk),         // Templated
+           .qlm1__ref_clk               (qlm1__ref_clk),         // Templated
+           .qlm2__ref_clk               (qlm2__ref_clk),         // Templated
+           .qlm3__ref_clk               (qlm3__ref_clk),         // Templated
+           .qlm4__ref_clk               (qlm4__ref_clk),         // Templated
+           .rsl__dbg_offset             (rsl__dbg_offset[3:0]),  // Templated
+           .rst__ciu_prtmode0           (rst__ciu_prtmode0),     // Templated
+           .rst__ciu_prtmode1           (rst__ciu_prtmode1),     // Templated
+           .rst__ciu_rboot              (rst__ciu_rboot),        // Templated
+           .rst__ciu_sft_prst           (rst__ciu_sft_prst[1:0]), // Templated
+           .rst__rsl_int                (rst__rsl_int),          // Templated
+           .scan_clken                  ({1'b0}),                // Templated
+           .scan_mode                   ({1'b0}),                // Templated
+           .sclk                        (tb_clk),                // Templated
+           .srst_cold_n                 (srst_cold_n),           // Templated
+           .srst_cold_or_warm_n         (srst_cold_or_warm_n),   // Templated
+           .srst_n                      (srst_n),                // Templated
+           .start_bist_1a               (start_bist_1a));         // Templated
+   
+
+   // proc: initial
+   // Clear out the unimportant signals
+   initial begin
+
+      qlm0__ref_clk = 0;
+      qlm1__ref_clk = 0;
+      qlm2__ref_clk = 0;
+      qlm3__ref_clk = 0;
+      qlm4__ref_clk = 0;
+
+      fus__ema = 0;
+      srst_cold_n = 0;
+      srst_cold_or_warm_n = 0;
+      srst_n = 0;
+      pi_chip_reset_n = 0;
+      start_bist_1a = 0;
+      rst__rsl_int = 0;
+      rst__ciu_prtmode0 = 0;
+      rst__ciu_prtmode1 = 0;
+      rst__ciu_rboot = 0;
+      rst__ciu_sft_prst = 0;
+      erst_0a_n = 0;
+      mio__clear_bist = 0;
+      mio__start_bist = 0;
+      rsl__dbg_offset = 0;
+
+      @(posedge tb_rst_n);
+      srst_n = 1;
+      srst_cold_or_warm_n = 1;
+      srst_cold_n = 1;
+      erst_0a_n = 1;      
+   end
+
+endmodule
+
+// Local Variables:
+// verilog-library-directories:  ("." "../../verif/hdl" "../../vkits/ncb" "../../rtl/alu" "../../rtl/mio")
+// verilog-library-extensions:  (".v" ".sv" ".svh")
+// End:
+
Index: verif/frm/Makefile
===================================================================
--- verif/frm/Makefile	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/verif)	(revision 0)
+++ verif/frm/Makefile	(.../verif)	(revision 0)
@@ -0,0 +1,76 @@
+#-*- mode: makefile;-*-
+# ******************************************************************************
+# * CAVIUM CONFIDENTIAL
+# *
+# *                         PROPRIETARY NOTE
+# *
+# *  
+# * This software contains information confidential and proprietary
+# * to Cavium.  It shall not be reproduced in whole or in
+# * part, or transferred to other documents, or disclosed to third
+# * parties, or used for any purpose other than that for which it was
+# * obtained, without the prior written consent of Cavium.
+# * (c) <year>, Cavium.  All rights reserved.
+# * (utg v<utgversion>)
+# *
+# ******************************************************************************
+# * File        : <filename>
+# * Author      : <author>
+# * Description : frm Makefile
+# *
+# ******************************************************************************
+
+################################################################################
+#################### Define some internal helper variables #####################
+################################################################################
+
+ROOT_DIR     ?= ../..
+TB_ROOT      =./$(TB_NAME)_tb_top.sv
+PROJECT_MODE =UVM
+SIMULATOR    = VCS
+
+ifndef DVTOOLS_DIR
+export DVTOOLS_DIR := $(shell find_dvtools)
+endif
+
+CSR_PKGS = $(ROOT_DIR)/verif/vkits/reg/obj/unit/regs__alu.sv
+
+FLISTS= verif/vkits/cn/cn.flist \
+   verif/vkits/global/global.flist \
+   verif/vkits/ncb/ncb.flist \
+   verif/vkits/alu/alu.flist \
+   verif/vkits/frm/frm.flist \
+   verif/frm/frm.flist \
+   verif/frm/rtl.flist
+
+SCOVROOT = $(ROOT_DIR)/rtl/$(TB_NAME)/$(TB_NAME).v
+
+ICTCOVSELECT = $(HDL_TOP).$(TB_NAME).*...
+
+#-------------------------------------------------------------------------------
+
+# Specify libraries required, only if they have C++, csr.py, or other build steps
+# Generic vkits that just provide an flist do not go in this list
+TB_XDIRS = ../regs
+TB_XDIRS_FULL += ../uvm_common
+TB_XDIRS_VKIT =  ../vkits/uvm/$(UVMREV)/src/uvm_dpi
+
+TB_LIBS = $(addprefix uvm_common.,$(subst $(COMMA), ,$(SIMULATOR)))
+
+ifeq ($(LIB),TB)
+INC_DIRS = . $(OBJ_DIR)/unit
+BASE=Tb
+SRC_DIRS=tb
+endif
+
+ifeq ($(LIB),TEST)
+INC_DIRS = . ./tb $(OBJ_DIR)/unit $(OBJ_DIR)/unitTb
+BASE=Test
+SRC_DIRS=tests
+endif
+
+ifdef LIB
+include $(DVTOOLS_DIR)/lib/Makefile.lib
+else
+include $(DVTOOLS_DIR)/lib/Makefile.sim
+endif
Index: rtl/alu/mio_alu.v
===================================================================
--- rtl/alu/mio_alu.v	(.../svn+ssh://masvn/svn/o68/branches/uvmtut_v0.6/rtl)	(revision 104137)
+++ rtl/alu/mio_alu.v	(.../rtl)	(working copy)
@@ -76,6 +76,8 @@
    reg [31:0] nxt_result;
    reg [31:0] result;
    reg        ready;
+
+   reg [15:0] denom;
    
    // register inputs
    always @(posedge sclk) begin
@@ -165,14 +167,18 @@
          ready      <= 1'b0;
          operation  <= 4'b0;
       end else begin
-         nxt_result <= (state == COMPUTE_1 && operation == ADD_A_B)?  (kval_r * (aval+bval) + cval_r) :
-                       (state == COMPUTE_1 && operation == SUB_A_B)?  (kval_r * (aval-bval) + cval_r) :
-                       (state == COMPUTE_1 && operation == SUB_B_A)?  (kval_r * (bval-aval) + cval_r) :
-                       (state == COMPUTE_1 && operation == INC_A)?    (kval_r * (aval+1)    + cval_r) :
-                       (state == COMPUTE_1 && operation == INC_B)?    (kval_r * (bval+1)    + cval_r) :
-                       (state == COMPUTE_2 && operation == MUL_A_B)?  (kval_r * (aval*bval) + cval_r) :
-                       (state == COMPUTE_3 && operation == DIV_A_B)?  (kval_r * (aval/bval) + cval_r) :
-                       (state == COMPUTE_3 && operation == DIV_B_A)?  (kval_r * (bval/aval) + cval_r) :
+         denom      <= (state == COMPUTE_1 && operation == DIV_A_B)? ((bval == 0)? 1 : bval) :
+                       (state == COMPUTE_1 && operation == DIV_B_A)? ((aval == 0)? 1 : aval) :
+                       denom;
+         
+         nxt_result <= (state == COMPUTE_1 && operation == ADD_A_B)?  (kval_r * (aval+bval)  + cval_r) :
+                       (state == COMPUTE_1 && operation == SUB_A_B)?  (kval_r * (aval-bval)  + cval_r) :
+                       (state == COMPUTE_1 && operation == SUB_B_A)?  (kval_r * (bval-aval)  + cval_r) :
+                       (state == COMPUTE_1 && operation == INC_A)?    (kval_r * (aval+1)     + cval_r) :
+                       (state == COMPUTE_1 && operation == INC_B)?    (kval_r * (bval+1)     + cval_r) :
+                       (state == COMPUTE_2 && operation == MUL_A_B)?  (kval_r * (aval*bval)  + cval_r) :
+                       (state == COMPUTE_3 && operation == DIV_A_B)?  (kval_r * (aval/denom) + cval_r) :
+                       (state == COMPUTE_3 && operation == DIV_B_A)?  (kval_r * (bval/denom) + cval_r) :
                        (state == COMPUTE_1 && operation == CLR_RES)?  0                                 :
                        (state == COMPUTE_1 && operation == ACCUM)?    (aval + result)                   :
                        nxt_result;
