diff --git a/verif/alutb/alu_wrapper.sv b/verif/alutb/alu_wrapper.sv
index 2ed57bf..904b542 100755
--- a/verif/alutb/alu_wrapper.sv
+++ b/verif/alutb/alu_wrapper.sv
@@ -14,19 +14,16 @@
 
 module alu_wrapper(input logic tb_clk,
                    tb_rst_n,
-                   ctx_intf ctx_i);
+                   ctx_intf ctx_i,
+                   alu_intf alu_i);
 
    /*AUTOREGINPUT*/
    // Beginning of automatic reg inputs (for undeclared instantiated-module inputs)
-   reg                  alu_ctl;                // To dut of alu.v
-   reg [7:0]            alu_dat;                // To dut of alu.v
    reg [4:0]            frame_len;              // To dut of alu.v
    reg                  frame_len_val;          // To dut of alu.v
    // End of automatics
    /*AUTOWIRE*/
    // Beginning of automatic wires (for undeclared instantiated-module outputs)
-   wire                 alu_ready;              // From dut of alu.v
-   wire [31:0]          alu_result;             // From dut of alu.v
    wire                 frame;                  // From dut of alu.v
    wire                 frame_bp;               // From dut of alu.v
    wire [31:0]          frame_data;             // From dut of alu.v
@@ -39,6 +36,7 @@ module alu_wrapper(input logic tb_clk,
     .ctx_\(.*\)   (ctx_i.\1[]),
     .clk          (tb_clk),
     .rst_n        (tb_rst_n),
+    .alu_\(.*\)   (alu_i.\1[]),
     .\(.*\) (\1[]),
     ); */
    alu dut(/*AUTOINST*/
@@ -47,11 +45,11 @@ module alu_wrapper(input logic tb_clk,
            .frame                       (frame),                 // Templated
            .frame_bp                    (frame_bp),              // Templated
            .frame_data                  (frame_data[31:0]),      // Templated
-           .alu_ready                   (alu_ready),             // Templated
-           .alu_result                  (alu_result[31:0]),      // Templated
+           .alu_ready                   (alu_i.ready),           // Templated
+           .alu_result                  (alu_i.result[31:0]),    // Templated
            // Inputs
-           .alu_ctl                     (alu_ctl),               // Templated
-           .alu_dat                     (alu_dat[7:0]),          // Templated
+           .alu_ctl                     (alu_i.ctl),             // Templated
+           .alu_dat                     (alu_i.dat[7:0]),        // Templated
            .clk                         (tb_clk),                // Templated
            .ctx_in                      (ctx_i.in[7:0]),         // Templated
            .ctx_val                     (ctx_i.val),             // Templated
diff --git a/verif/alutb/alutb.flist b/verif/alutb/alutb.flist
index 59fb1e8..9d89e57 100755
--- a/verif/alutb/alutb.flist
+++ b/verif/alutb/alutb.flist
@@ -6,7 +6,9 @@
 +incdir+../../rtl/include
 ../../verif/alutb/alutb_tb_top.sv
 ../../verif/alutb/alu_wrapper.sv
+../../verif/alutb/clk_duty_cycle.sv
 ../../verif/alutb/tests/basic.sv
 ../../verif/alutb/tests/base_test.sv
+../../verif/alutb/tests/fast_clk.sv
+../../verif/alutb/tests/duty_cycle.sv
 -f ../../verif/alutb/rtl.flist
-
diff --git a/verif/alutb/alutb_tb_top.sv b/verif/alutb/alutb_tb_top.sv
index e789596..c1fb694 100755
--- a/verif/alutb/alutb_tb_top.sv
+++ b/verif/alutb/alutb_tb_top.sv
@@ -34,6 +34,12 @@ module alutb_tb_top;
    // CTX Interface
    ctx_intf ctx_i(.clk(tb_clk), .rst_n(tb_rst_n));
 
+   // obj: alu_i
+   // The <alu_intf> instance
+   alu_intf alu_i(.clk(tb_clk), .rst_n(tb_rst_n));
+   initial
+      alu_i.reset();
+
    //----------------------------------------------------------------------------------------
    // Group: DUT
 
@@ -41,6 +47,7 @@ module alutb_tb_top;
    alu_wrapper alu_wrapper(/*AUTOINST*/
                            // Interfaces
                            .ctx_i               (ctx_i),
+                           .alu_i               (alu_i),
                            // Inputs
                            .tb_clk              (tb_clk),
                            .tb_rst_n            (tb_rst_n));
@@ -56,6 +63,8 @@ module alutb_tb_top;
       `cn_set_intf(virtual cn_rst_intf    , "cn_pkg::rst_intf"  , "tb_rst_vi", tb_rst_i);
       `cn_set_intf(virtual ctx_intf.drv_mp , "ctx_pkg::ctx_intf" , "ctx_vi"   , ctx_i.drv_mp);
       `cn_set_intf(virtual ctx_intf.mon_mp , "ctx_pkg::ctx_intf" , "ctx_vi"   , ctx_i.mon_mp);
+      `cn_set_intf(virtual alu_intf.drv_mp, "alu_pkg::alu_intf", "drv_vi", alu_i.drv_mp)
+      `cn_set_intf(virtual alu_intf.mon_mp, "alu_pkg::alu_intf", "mon_vi", alu_i.mon_mp)
    endfunction : pre_run_test
 
    `include "tb_common.v"
diff --git a/verif/alutb/clk_duty_cycle.sv b/verif/alutb/clk_duty_cycle.sv
new file mode 100755
index 0000000..73d60ed
--- /dev/null
+++ b/verif/alutb/clk_duty_cycle.sv
@@ -0,0 +1,54 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   clk_duty_cycle.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __CLK_DUTY_CYCLE_SV__
+   `define __CLK_DUTY_CYCLE_SV__
+
+
+// (`includes go here)
+
+// class: clk_duty_cycle_c
+// A clock with a duty cycle of 75/25.
+class clk_duty_cycle_c extends cn_pkg::clk_drv_c;
+   `uvm_component_utils(clk_duty_cycle_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="clk_duty_cycle",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      int uptime = 3*period_ps / 4;
+      int downtime = period_ps - uptime;
+
+      // set to initial value
+      clk_vi.clk = (init_x)? 'bx : init_value;
+      #(init_delay_ps * 1ps);
+
+      forever begin
+         clk_vi.clk = 1;
+         #(uptime * 1ps);
+         clk_vi.clk = 0;
+         #(downtime * 1ps);
+      end
+   endtask : run_phase
+
+endclass : clk_duty_cycle_c
+
+`endif // __CLK_DUTY_CYCLE_SV__
+
diff --git a/verif/alutb/tb.py b/verif/alutb/tb.py
index 3adcb12..113627f 100755
--- a/verif/alutb/tb.py
+++ b/verif/alutb/tb.py
@@ -1,5 +1,5 @@
 # Add vkit dependencies *in order*
-VKITS = ['cn', 'global', 'csr', 'ctx', 'alutb']
+VKITS = ['cn', 'global', 'csr', 'ctx', 'alu', 'alutb']
 
 # Add testbench flists
 FLISTS = ['alutb.flist', 'rtl.flist']
diff --git a/verif/alutb/tests/basic.sv b/verif/alutb/tests/basic.sv
index a6fcbf3..0eba3d3 100755
--- a/verif/alutb/tests/basic.sv
+++ b/verif/alutb/tests/basic.sv
@@ -23,17 +23,45 @@ class basic_test_c extends base_test_c;
    `uvm_component_utils(basic_test_c)
 
    //----------------------------------------------------------------------------------------
-   // Methods
+   // Group: Methods
    function new(string name="test",
                 uvm_component parent=null);
       super.new(name, parent);
    endfunction : new
 
    ////////////////////////////////////////////
-   // func: build_phase
-   virtual function void build_phase(uvm_phase phase);
-      super.build_phase(phase);
-   endfunction : build_phase
+   // func: main_phase
+   virtual task main_phase(uvm_phase phase);
+      alu_pkg::sum_of_factorials_seq_c sof_seq = new("sof");
+      alu_pkg::sum_array_seq_c sum_array_seq = new("sum_array");
+      alu_pkg::exer_seq_c exer_seq = new("exer_seq");
+
+      phase.raise_objection(this);
+      fork
+         begin
+            sof_seq.randomize();
+            `cn_info(("Starting:\\n%s", sof_seq.sprint()))
+            sof_seq.start(alutb_env.alu_agent.sqr);
+            `cn_info(("The sum-of-factorials from %0d to %0d is %d",
+                      sof_seq.op_x, sof_seq.op_y, sof_seq.result))
+         end
+
+         begin
+            sum_array_seq.randomize() with {data.size() > 8; };
+            `cn_info(("Starting:\\n%s", sum_array_seq.sprint()))
+            sum_array_seq.start(alutb_env.alu_agent.sqr);
+            `cn_info(("The sum is %0d", sum_array_seq.result))
+         end
+
+         begin
+            alu_pkg::factorial_seq_c fact_seq = new("fact_seq");
+            fact_seq.randomize();
+            fact_seq.start(alutb_env.alu_agent.sqr);
+         end
+      join
+
+      phase.drop_objection(this);
+   endtask : main_phase
 
 endclass : basic_test_c
 
diff --git a/verif/alutb/tests/duty_cycle.sv b/verif/alutb/tests/duty_cycle.sv
new file mode 100755
index 0000000..0940097
--- /dev/null
+++ b/verif/alutb/tests/duty_cycle.sv
@@ -0,0 +1,43 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   duty_cycle.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __DUTY_CYCLE_SV__
+   `define __DUTY_CYCLE_SV__
+
+   `include "base_test.sv"
+   `include "clk_duty_cycle.sv"
+
+// class: duty_cycle_test_c
+// Run using the clk_duty_cycle_c instead of cn_pkg::clk_drv_c
+class duty_cycle_test_c extends base_test_c;
+   `uvm_component_utils(duty_cycle_test_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="duty_cycle_test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      set_type_override_by_type(cn_pkg::clk_drv_c::get_type(),
+                                clk_duty_cycle_c::get_type(), .replace(1));
+      super.build_phase(phase);
+   endfunction : build_phase
+
+endclass : duty_cycle_test_c
+
+`endif // __DUTY_CYCLE_SV__
diff --git a/verif/alutb/tests/fast_clk.sv b/verif/alutb/tests/fast_clk.sv
new file mode 100755
index 0000000..7cd5536
--- /dev/null
+++ b/verif/alutb/tests/fast_clk.sv
@@ -0,0 +1,72 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   fast_clk.sv
+// Author: bhunter
+/* About:  A test that makes the clock go super fast!
+ *************************************************************************/
+
+`ifndef __FAST_CLK_SV__
+   `define __FAST_CLK_SV__
+
+
+   `include "base_test.sv"
+// (`includes go here)
+
+// class: fast_clk_test_c
+// (Describe me)
+class fast_clk_test_c extends base_test_c;
+   `uvm_component_utils_begin(fast_clk_test_c)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="test",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+      tb_clk_drv.randomize(period_ps) with {
+         period_ps inside {[1800:1999]};
+      };
+      `cn_info(("Selected a period of %0dps", tb_clk_drv.period_ps))
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      super.run_phase(phase);
+   endtask : run_phase
+
+endclass : fast_clk_test_c
+
+`endif // __FAST_CLK_SV__
+
diff --git a/verif/vkits/alu/alu.flist b/verif/vkits/alu/alu.flist
new file mode 100755
index 0000000..6d7328f
--- /dev/null
+++ b/verif/vkits/alu/alu.flist
@@ -0,0 +1,4 @@
++incdir+../../verif/vkits/alu
+../../verif/vkits/alu/alu_intf.sv
+../../verif/vkits/alu/alu_pkg.sv
+
diff --git a/verif/vkits/alu/alu_agent.sv b/verif/vkits/alu/alu_agent.sv
new file mode 100755
index 0000000..01dadea
--- /dev/null
+++ b/verif/vkits/alu/alu_agent.sv
@@ -0,0 +1,108 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_agent.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_AGENT_SV__
+   `define __ALU_AGENT_SV__
+
+
+`include "alu_drv.sv"
+`include "alu_mon.sv"
+`include "alu_sqr.sv"
+// (`includes go here)
+
+// class: agent_c
+// (Description)
+class agent_c extends uvm_agent;
+   `uvm_component_utils_begin(alu_pkg::agent_c)
+      `uvm_field_enum(uvm_active_passive_enum, is_active, UVM_ALL_ON)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   // field: is_active
+   // When set to UVM_ACTIVE, the sqr and drv will be present.
+   uvm_active_passive_enum is_active = UVM_ACTIVE;
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   // field: monitored_item_port
+   // All monitored transactions go out here
+   uvm_analysis_port #(item_c) monitored_item_port;
+
+   // field: monitored_result_port
+   // All monitored results go out here
+   uvm_analysis_port #(result_t) monitored_result_port;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // fields: drv, mon, sqr
+   // Driver, monitor, and sequencer found in most agents
+   sqr_c sqr;
+   drv_c drv;
+   mon_c mon;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="agent",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+
+      mon = mon_c::type_id::create("mon", this);
+      monitored_item_port = new("monitored_item_port", this);
+      monitored_result_port = new("monitored_result_port", this);
+
+      if(is_active) begin
+         drv = drv_c::type_id::create("drv", this);
+         sqr = sqr_c::type_id::create("sqr", this);
+      end
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+
+      // connect to the monitor's analysis ports
+      mon.monitored_item_port.connect(monitored_item_port);
+      mon.monitored_result_port.connect(monitored_result_port);
+
+     if(is_active)
+         drv.seq_item_port.connect(sqr.seq_item_export);
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      super.run_phase(phase);
+   endtask : run_phase
+
+endclass : agent_c
+
+`endif // __ALU_AGENT_SV__
+
diff --git a/verif/vkits/alu/alu_drv.sv b/verif/vkits/alu/alu_drv.sv
new file mode 100755
index 0000000..1dad324
--- /dev/null
+++ b/verif/vkits/alu/alu_drv.sv
@@ -0,0 +1,81 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_drv.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_DRV_SV__
+   `define __ALU_DRV_SV__
+
+`include "alu_item.sv"
+
+// class: drv_c
+// (Describe me)
+class drv_c extends uvm_driver#(item_c);
+   `uvm_component_utils_begin(alu_pkg::drv_c)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="drv",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      result_t prev_result;
+      
+      forever begin
+         seq_item_port.get_next_item(req);
+         `cn_info(("Driving: %s", req.convert2string()))
+         case(req.operation)
+            item_c::MUL_A_B:  req.result = result_t'(req.alpha * req.beta);
+            item_c::ACCUM:    req.result = result_t'(prev_result + req.alpha);
+            item_c::CLR_RES:  req.result = 0;
+         endcase
+         prev_result = req.result;
+         seq_item_port.item_done(req);
+      end
+   endtask : run_phase
+
+endclass : drv_c
+
+`endif // __ALU_DRV_SV__
+
diff --git a/verif/vkits/alu/alu_intf.sv b/verif/vkits/alu/alu_intf.sv
new file mode 100755
index 0000000..42f6821
--- /dev/null
+++ b/verif/vkits/alu/alu_intf.sv
@@ -0,0 +1,114 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_intf.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_INTF_SV__
+   `define __ALU_INTF_SV__
+
+// class: alu_intf
+interface alu_intf(input logic clk,
+                   input logic rst_n);
+
+   import uvm_pkg::*;
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Signals
+
+   // var: ctl
+   // Asserted only on the first cycle of a new transaction, while dat contains the operation
+   logic        ctl;
+
+   // var: dat
+   // The input data nibble that contains the operation and operands
+   logic [7:0]  dat;
+
+   // var: ready
+   // The output of the ALU that indicates when the result data is valid
+   logic        ready;
+
+   // var: result
+   // The 32-bit result data
+   logic [31:0] result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Clocking blocks
+
+   // var: drv_cb
+   // A clocking block that represents how the environment's driver sees the interface
+   clocking drv_cb @(posedge clk);
+      output    ctl;
+      output    dat;
+      input     ready;
+      input     result;
+      input     rst_n;
+   endclocking : drv_cb
+
+   // var: mon_cb
+   // A clocking block that represents how the environment's monitor sees the interface
+   clocking mon_cb @(posedge clk);
+      input     ctl;
+      input     dat;
+      input     ready;
+      input     result;
+      input     rst_n;
+   endclocking : mon_cb
+
+   //----------------------------------------------------------------------------------------
+   // Group: Modports
+
+   modport drv_mp(clocking drv_cb,
+                  import reset);
+   modport mon_mp(clocking mon_cb);
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+
+   // func: reset
+   // Convenience function for the driver to reset its outputs
+   function void reset();
+      ctl = 0;
+      dat = 8'b0;
+   endfunction : reset
+
+   //----------------------------------------------------------------------------------------
+   // Group: Assertions
+
+   ctl_not_x :
+      assert property(@(posedge clk)
+                      disable iff (~rst_n || rst_n === 1'bx)
+                      (!$isunknown(ctl))) else
+         `cn_err_intf(("ctl signal is an X"))
+
+   dat_not_x :       
+      assert property(@(posedge clk)
+                      disable iff (~rst_n || rst_n === 1'bx)
+                      (!$isunknown(dat))) else
+         `cn_err_intf(("dat signal is an X"))
+
+   ready_not_x : 
+      assert property(@(posedge clk)
+                      disable iff (~rst_n || rst_n === 1'bx)
+                      (!$isunknown(ready))) else
+         `cn_err_intf(("ready signal is an X"))
+
+   result_not_x : 
+      assert property(@(posedge clk)
+                      disable iff (~rst_n || rst_n === 1'bx || ready == 0)
+                      (!$isunknown(result))) else
+         `cn_err_intf(("result signal is an X"))
+         
+endinterface : alu_intf
+
+
+`endif // __ALU_INTF_SV__
+
diff --git a/verif/vkits/alu/alu_item.sv b/verif/vkits/alu/alu_item.sv
new file mode 100755
index 0000000..49d3caa
--- /dev/null
+++ b/verif/vkits/alu/alu_item.sv
@@ -0,0 +1,119 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_item.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_ITEM_SV__
+   `define __ALU_ITEM_SV__
+
+// class: item_c
+// An ALU Transaction as a sequence item
+class item_c extends uvm_sequence_item;
+   //----------------------------------------------------------------------------------------
+   // Group: Types
+   typedef enum bit [7:0] {
+                           ADD_A_B = 0,
+                           SUB_A_B = 1,
+                           SUB_B_A = 2,
+                           MUL_A_B = 3,
+                           DIV_A_B = 4,
+                           DIV_B_A = 5,
+                           INC_A   = 6,
+                           INC_B   = 7,
+                           CLR_RES = 8,
+                           ACCUM   = 9
+                           } operation_e;
+
+   `uvm_object_utils_begin(alu_pkg::item_c)
+      `uvm_field_enum(operation_e, operation, UVM_ALL_ON)
+      `uvm_field_int (alpha,                  UVM_ALL_ON | UVM_NOPACK | UVM_NOCOMPARE)
+      `uvm_field_int (beta,                   UVM_ALL_ON | UVM_NOPACK | UVM_NOCOMPARE)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // var: operation
+   rand operation_e operation;
+
+   // var: A variable
+   rand bit [15:0] alpha;
+
+   // var: B variable
+   rand bit [15:0] beta;
+
+   // ensure that all operands have legal values
+   constraint protocol_cnstr {
+      (operation == DIV_A_B) -> beta != 0;
+      (operation == DIV_B_A) -> alpha != 0;
+      (operation == SUB_A_B) -> alpha > beta;
+      (operation == SUB_B_A) -> beta > alpha;
+   }
+
+   // var: result
+   // This is the result of the operation, filled in by the driver and sent back with the response
+   result_t result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="item");
+      super.new(name);
+   endfunction : new
+
+   //----------------------------------------------------------------------------------------
+   // func: convert2string
+   // Single-line printing
+   virtual function string convert2string();
+      convert2string = $psprintf("%s A:%04X B:%04X", operation, alpha, beta);
+   endfunction : convert2string
+
+   ////////////////////////////////////////////
+   // func: do_pack
+   virtual function void do_pack(uvm_packer packer);
+      super.do_pack(packer);
+
+      if(operation inside {[ADD_A_B : INC_A], ACCUM})
+         packer.pack_field_int(alpha, 16);
+      if(operation inside {[ADD_A_B : DIV_B_A], INC_B})
+         packer.pack_field_int(beta, 16);
+   endfunction : do_pack
+
+   ////////////////////////////////////////////
+   // func: do_unpack
+   virtual function void do_unpack(uvm_packer packer);
+      super.do_unpack(packer);
+
+      if(operation inside {[ADD_A_B : INC_A], ACCUM})
+         alpha = packer.unpack_field_int(16);
+      if(operation inside {[ADD_A_B : DIV_B_A], INC_B})
+         beta = packer.unpack_field_int(16);
+   endfunction : do_unpack
+
+   ////////////////////////////////////////////
+   // func: do_compare
+   virtual function bit do_compare(uvm_object rhs,
+                                   uvm_comparer comparer);
+      item_c _rhs;
+      $cast(_rhs, rhs);
+      do_compare = super.do_compare(rhs, comparer);
+      if(operation inside {[ADD_A_B : INC_A], ACCUM})
+         do_compare &= comparer.compare_field_int("alpha", alpha, _rhs.alpha, 16);
+      if(operation inside {[ADD_A_B : DIV_B_A], INC_B})
+         do_compare &= comparer.compare_field_int("beta", beta, _rhs.beta, 16);
+   endfunction : do_compare
+
+endclass : item_c
+
+
+`endif // __ALU_ITEM_SV__
+
+
diff --git a/verif/vkits/alu/alu_mon.sv b/verif/vkits/alu/alu_mon.sv
new file mode 100755
index 0000000..c15dab2
--- /dev/null
+++ b/verif/vkits/alu/alu_mon.sv
@@ -0,0 +1,85 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_mon.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_MON_SV__
+   `define __ALU_MON_SV__
+
+
+// (`includes go here)
+
+// class: mon_c
+// (Describe me)
+class mon_c extends uvm_monitor;
+   `uvm_component_utils_begin(alu_pkg::mon_c)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   // field: monitored_item_port
+   // All monitored transactions go out here
+   uvm_analysis_port #(item_c) monitored_item_port;
+
+   // field: monitored_result_port
+   // All monitored results go out here
+   uvm_analysis_port #(result_t) monitored_result_port;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="mon",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+      monitored_item_port = new("monitored_item_port", this);
+      monitored_result_port = new("monitored_result_port", this);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      super.run_phase(phase);
+   endtask : run_phase
+
+   ////////////////////////////////////////////
+   // func: main_phase
+   virtual task main_phase(uvm_phase phase);
+   endtask : main_phase
+   
+endclass : mon_c
+
+`endif // __ALU_MON_SV__
+
diff --git a/verif/vkits/alu/alu_pkg.sv b/verif/vkits/alu/alu_pkg.sv
new file mode 100755
index 0000000..da06086
--- /dev/null
+++ b/verif/vkits/alu/alu_pkg.sv
@@ -0,0 +1,43 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_pkg.sv
+// Author: bhunter
+/* About:  alu package
+ *************************************************************************/
+
+
+// (`includes of macros may go here)
+`include "uvm_macros.svh"
+
+// package: alu_pkg
+// (Describe me)
+package alu_pkg;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Imports
+   import uvm_pkg::*;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Types
+   typedef logic [31:0] result_t;
+   
+   //----------------------------------------------------------------------------------------
+   // Group: Includes
+
+`include "alu_agent.sv"
+`include "alu_drv.sv"
+`include "alu_item.sv"
+`include "alu_mon.sv"
+`include "alu_seq_lib.sv"
+`include "alu_sqr.sv"
+
+endpackage : alu_pkg
+
+
diff --git a/verif/vkits/alu/alu_seq_lib.sv b/verif/vkits/alu/alu_seq_lib.sv
new file mode 100755
index 0000000..3e75572
--- /dev/null
+++ b/verif/vkits/alu/alu_seq_lib.sv
@@ -0,0 +1,239 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_seq_lib.sv
+// Author: bhunter
+/* About:  [description]
+ *************************************************************************/
+
+`ifndef __ALU_SEQ_LIB_SV__
+   `define __ALU_SEQ_LIB_SV__
+
+   `include "alu_item.sv"
+
+// Forward declaration of library sequence
+/* -----\/----- EXCLUDED -----\/-----
+typedef class lib_seq_c;
+ -----/\----- EXCLUDED -----/\----- */
+
+//****************************************************************************************
+// class: exer_seq_c
+// Runs <count> transactions
+class exer_seq_c extends uvm_sequence #(item_c, item_c);
+   `uvm_object_utils_begin(alu_pkg::exer_seq_c)
+      `uvm_field_int(count, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // field: count
+   // The number of random transactions to perform
+   rand int count;
+   constraint reasonable_cnstr { count inside {[1:100]}; }
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+
+   function new(string name="alu_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      item_c item;
+
+      repeat(count) begin
+         `uvm_do(item)
+         get_response(rsp);
+         `cn_info(("Got response result: %08X", rsp.result))
+      end
+   endtask
+endclass : exer_seq_c
+
+//****************************************************************************************
+// class: factorial_seq_c
+// Calculates the factorial of the operand value
+class factorial_seq_c extends uvm_sequence #(item_c, item_c);
+   `uvm_object_utils_begin(alu_pkg::factorial_seq_c)
+      `uvm_field_int(operand, UVM_ALL_ON)
+      `uvm_field_int(result,  UVM_ALL_ON)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // field: operand
+   // The value to perform the factorial on
+   rand bit [15:0] operand;
+   constraint operand_cnstr { operand <= 9; }
+
+   // field: result
+   // The final result
+   result_t result = 1;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="factorial_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   // Loop from 1..operand and multiply all the numbers together
+   virtual task body();
+      item_c item;
+      byte num;
+
+      for(num = 1; num <= operand; num++) begin
+         `uvm_do_with(item, { operation == MUL_A_B; alpha == num; beta == local::result[15:0]; })
+         get_response(rsp);
+         result = rsp.result;
+         `cn_info(("num=%0d, result=%0d", num, result))
+      end
+      `cn_info(("%0d! = %0d", operand, result))
+   endtask : body
+endclass : factorial_seq_c
+
+//****************************************************************************************
+// class: sum_array_seq_c
+// Creates a randomly-sized array and adds up their values
+class sum_array_seq_c extends uvm_sequence #(item_c, item_c);
+   `uvm_object_utils_begin(alu_pkg::sum_array_seq_c)
+      `uvm_field_array_int(data, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // field: data
+   // An array of words to be summed
+   rand bit [15:0] data[];
+
+   // constraint: data_cnstr
+   // keep it to a reasonable size
+   // and use small numbers only
+   constraint data_cnstr { 
+      data.size() inside {[1:50]};
+      foreach(data[x]) {
+         data[x] inside {[0:100]};
+      }
+   }
+
+   // field: result
+   // The final answer
+   result_t result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+
+   function new(string name="sum_array_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      item_c item;
+
+      lock();
+      `uvm_do_with(item, { operation == CLR_RES; })
+      get_response(rsp);
+      foreach(data[x]) begin
+         `uvm_do_with(item, { operation == ACCUM; alpha == data[x]; })
+         get_response(rsp);
+      end
+      unlock();
+      result = rsp.result;
+      `cn_info(("Sum of this array = %0x:", result))
+   endtask : body
+endclass : sum_array_seq_c
+
+//****************************************************************************************
+// class: sum_of_factorials_seq_c
+// Sum the factorials between op_x and op_y
+class sum_of_factorials_seq_c extends uvm_sequence #(item_c);
+   `uvm_object_utils_begin(alu_pkg::sum_of_factorials_seq_c)
+      `uvm_field_int(op_x, UVM_ALL_ON | UVM_DEC)
+      `uvm_field_int(op_y, UVM_ALL_ON | UVM_DEC)
+      `uvm_field_int(result, UVM_ALL_ON | UVM_DEC)
+   `uvm_object_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   // vars: op_x, op_y
+   // Operands for this summation function
+   rand bit [15:0] op_x;
+   rand bit [15:0] op_y;
+
+   constraint operands_cnstr {
+      op_x < op_y;
+      op_x inside {[1:8]};
+      op_y inside {[1:8]};
+   }
+
+   // field: result
+   // The final result
+   result_t result;
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="sum_of_factorials_array_seq");
+      super.new(name);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: body
+   virtual task body();
+      int num;
+      bit [15:0] data[];
+      factorial_seq_c fact_seq;
+      sum_array_seq_c sum_seq;
+      int  idx;
+
+      // fill the data array with all the factorials
+      data = new[(op_y - op_x + 1)];
+      idx = 0;
+      for(num = op_x; num <= op_y; num++) begin
+         `uvm_do_with(fact_seq, { operand == num; })
+         data[idx] = fact_seq.result;
+         idx++;
+      end
+
+      // now sum the array
+      `uvm_create(sum_seq)
+      sum_seq.data = data;
+      `uvm_send(sum_seq)
+      result = sum_seq.result;
+      `cn_info(("The sum of factorials from %0d to %0d is %0d.",
+                op_x, op_y, result))
+   endtask : body
+endclass : sum_of_factorials_seq_c
+
+//****************************************************************************************
+/* -----\/----- EXCLUDED -----\/-----
+class lib_seq_c extends uvm_sequence_library #(item_c);
+   `uvm_object_utils(alu_pkg::lib_seq_c)
+   `uvm_sequence_library_utils(lib_seq_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="lib_seq");
+      super.new(name);
+      init_sequence_library();
+   endfunction : new
+
+endclass : lib_seq_c
+ -----/\----- EXCLUDED -----/\----- */
+
+
+`endif // __ALU_SEQ_LIB_SV__
+
diff --git a/verif/vkits/alu/alu_sqr.sv b/verif/vkits/alu/alu_sqr.sv
new file mode 100755
index 0000000..35e7e85
--- /dev/null
+++ b/verif/vkits/alu/alu_sqr.sv
@@ -0,0 +1,69 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alu_sqr.sv
+// Author: bhunter
+/* About:  <description>
+ *************************************************************************/
+
+`ifndef __ALU_SQR_SV__
+   `define __ALU_SQR_SV__
+
+`include "alu_item.sv"
+
+// class: sqr_c
+// (Describe me)
+class sqr_c extends uvm_sequencer#(item_c);
+   `uvm_component_utils_begin(alu_pkg::sqr_c)
+   `uvm_component_utils_end
+
+   //----------------------------------------------------------------------------------------
+   // Group: Configuration Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: TLM Ports
+
+   //----------------------------------------------------------------------------------------
+   // Group: Fields
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="sqr",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+   ////////////////////////////////////////////
+   // func: build_phase
+   virtual function void build_phase(uvm_phase phase);
+      super.build_phase(phase);
+   endfunction : build_phase
+
+   ////////////////////////////////////////////
+   // func: connect_phase
+   virtual function void connect_phase(uvm_phase phase);
+      super.connect_phase(phase);
+   endfunction : connect_phase
+
+   ////////////////////////////////////////////
+   // func: end_of_elaboration_phase
+   virtual function void end_of_elaboration_phase(uvm_phase phase);
+      super.end_of_elaboration_phase(phase);
+   endfunction : end_of_elaboration_phase
+
+   ////////////////////////////////////////////
+   // func: run_phase
+   virtual task run_phase(uvm_phase phase);
+      super.run_phase(phase);
+   endtask : run_phase
+
+endclass : sqr_c
+
+`endif // __ALU_SQR_SV__
+
diff --git a/verif/vkits/alutb/alutb_alu_item_subscriber.sv b/verif/vkits/alutb/alutb_alu_item_subscriber.sv
new file mode 100755
index 0000000..6b3b417
--- /dev/null
+++ b/verif/vkits/alutb/alutb_alu_item_subscriber.sv
@@ -0,0 +1,39 @@
+//-*- mode: Verilog; verilog-indent-level: 3; indent-tabs-mode: nil; tab-width: 1 -*-
+
+// **********************************************************************
+// *
+// * legal mumbo jumbo
+// *
+// * Copyright 2013
+// * (utg v0.8.2)
+// ***********************************************************************
+// File:   alutb_alu_item_subscriber.sv
+// Author: bhunter
+/* About:   Listens for all monitored ALU transactions.
+ *************************************************************************/
+
+`ifndef __ALUTB_ALU_ITEM_SUBSCRIBER_SV__
+   `define __ALUTB_ALU_ITEM_SUBSCRIBER_SV__
+
+// class: alu_item_subscriber_c
+// Print out all ALU transactions.
+class alu_item_subscriber_c extends uvm_subscriber#(alu_pkg::item_c);
+   `uvm_component_utils(alutb_pkg::alu_item_subscriber_c)
+
+   //----------------------------------------------------------------------------------------
+   // Group: Methods
+   function new(string name="alu_item_subscriber",
+                uvm_component parent=null);
+      super.new(name, parent);
+   endfunction : new
+
+    ////////////////////////////////////////////
+   // func: write
+   // Receives the alu_pkg::item_c
+   virtual function void write(alu_pkg::item_c t);
+      `cn_info(("Received this ALU transaction: %s", t.convert2string()))
+   endfunction : write
+endclass : alu_item_subscriber_c
+
+`endif // __ALUTB_ALU_ITEM_SUBSCRIBER_SV__
+
diff --git a/verif/vkits/alutb/alutb_env.sv b/verif/vkits/alutb/alutb_env.sv
index 667f35f..f60ed7b 100755
--- a/verif/vkits/alutb/alutb_env.sv
+++ b/verif/vkits/alutb/alutb_env.sv
@@ -17,6 +17,7 @@
    `define __ALUTB_ENV_SV__
 
    `include "alutb_cfg.sv"
+   `include "alutb_alu_item_subscriber.sv"
 
 // class: env_c
 // ALUTB Environment class
@@ -44,9 +45,17 @@ class env_c extends uvm_env;
    //----------------------------------------------------------------------------------------
    // Group: Fields
 
-   // field: Drives the CTX traffic
+   // field: ctx_agent
+   // Drives the CTX traffic
    ctx_pkg::agent_c ctx_agent;
 
+   // field: alu_agent
+   // The ALU agent
+   alu_pkg::agent_c alu_agent;
+
+   // field: alu_item_subscriber
+   alu_item_subscriber_c alu_item_subscriber;
+
    //----------------------------------------------------------------------------------------
    // Group: Methods
    function new(string name="env",
@@ -62,12 +71,18 @@ class env_c extends uvm_env;
 
       // build ctx agent
       ctx_agent = ctx_pkg::agent_c::type_id::create("ctx_agent", this);
+
+      // create the ALU agent
+      uvm_config_db#(int)::set(this, "alu_agent", "is_active", is_active);
+      alu_agent = alu_pkg::agent_c::type_id::create("alu_agent", this);
+      alu_item_subscriber = alu_item_subscriber_c::type_id::create("alu_item_subscriber", this);
    endfunction : build_phase
 
    ////////////////////////////////////////////
    // func: connect_phase
    virtual function void connect_phase(uvm_phase phase);
       super.connect_phase(phase);
+      alu_agent.monitored_item_port.connect(alu_item_subscriber.analysis_export);
    endfunction : connect_phase
 
    ////////////////////////////////////////////
diff --git a/verif/vkits/alutb/alutb_pkg.sv b/verif/vkits/alutb/alutb_pkg.sv
index 1997758..70fbedd 100755
--- a/verif/vkits/alutb/alutb_pkg.sv
+++ b/verif/vkits/alutb/alutb_pkg.sv
@@ -25,9 +25,10 @@ package alutb_pkg;
 
    //----------------------------------------------------------------------------------------
    // Group: Includes
+`include "alutb_alu_item_subscriber.sv"
 `include "alutb_cfg.sv"
 `include "alutb_env.sv"
-
+   
 endpackage : alutb_pkg
 
 
