Index: rtl/alu/mio_alu.v
===================================================================
--- rtl/alu/mio_alu.v	(.../spoc/rtl/alu/mio_alu.v)	(revision 93626)
+++ rtl/alu/mio_alu.v	(.../uvmtut/rtl/alu/mio_alu.v)	(working copy)
@@ -76,6 +76,8 @@
    reg [31:0] nxt_result;
    reg [31:0] result;
    reg        ready;
+
+   reg [15:0] denom;
    
    // register inputs
    always @(posedge sclk) begin
@@ -165,14 +167,18 @@
          ready      <= 1'b0;
          operation  <= 4'b0;
       end else begin
-         nxt_result <= (state == COMPUTE_1 && operation == ADD_A_B)?  (kval_r * (aval+bval) + cval_r) :
-                       (state == COMPUTE_1 && operation == SUB_A_B)?  (kval_r * (aval-bval) + cval_r) :
-                       (state == COMPUTE_1 && operation == SUB_B_A)?  (kval_r * (bval-aval) + cval_r) :
-                       (state == COMPUTE_1 && operation == INC_A)?    (kval_r * (aval+1)    + cval_r) :
-                       (state == COMPUTE_1 && operation == INC_B)?    (kval_r * (bval+1)    + cval_r) :
-                       (state == COMPUTE_2 && operation == MUL_A_B)?  (kval_r * (aval*bval) + cval_r) :
-                       (state == COMPUTE_3 && operation == DIV_A_B)?  (kval_r * (aval/bval) + cval_r) :
-                       (state == COMPUTE_3 && operation == DIV_B_A)?  (kval_r * (bval/aval) + cval_r) :
+         denom      <= (state == COMPUTE_1 && operation == DIV_A_B)? ((bval == 0)? 1 : bval) :
+                       (state == COMPUTE_1 && operation == DIV_B_A)? ((aval == 0)? 1 : aval) :
+                       denom;
+         
+         nxt_result <= (state == COMPUTE_1 && operation == ADD_A_B)?  (kval_r * (aval+bval)  + cval_r) :
+                       (state == COMPUTE_1 && operation == SUB_A_B)?  (kval_r * (aval-bval)  + cval_r) :
+                       (state == COMPUTE_1 && operation == SUB_B_A)?  (kval_r * (bval-aval)  + cval_r) :
+                       (state == COMPUTE_1 && operation == INC_A)?    (kval_r * (aval+1)     + cval_r) :
+                       (state == COMPUTE_1 && operation == INC_B)?    (kval_r * (bval+1)     + cval_r) :
+                       (state == COMPUTE_2 && operation == MUL_A_B)?  (kval_r * (aval*bval)  + cval_r) :
+                       (state == COMPUTE_3 && operation == DIV_A_B)?  (kval_r * (aval/denom) + cval_r) :
+                       (state == COMPUTE_3 && operation == DIV_B_A)?  (kval_r * (bval/denom) + cval_r) :
                        (state == COMPUTE_1 && operation == CLR_RES)?  0                                 :
                        (state == COMPUTE_1 && operation == ACCUM)?    (aval + result)                   :
                        nxt_result;
